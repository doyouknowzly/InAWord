## TCP协议

<img src="https://img-blog.csdnimg.cn/20200314211133115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc1MDkwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 80%;" />

| 序号 | 问题        | 一句话总结 |
| ---- | -------------------------- | --- |
| 1    | TCP协议的报文概述          ||
| 2    | TCP协议和UDP协议的对比     ||
| 3    | 为什么要3次握手，2次不行么 ||
| 4    | 为什么要4次挥手            ||
| 5    | TCP的滑动窗口             | 场景：处理consumer和provider处理速度不匹配的问题             |
| 6    | TCP的拥塞控制              |场景: 网络中报文过多，互相竞争导致拥塞怎么办？<br>手段: 慢启动、拥塞避免、快速重传、快速恢复|
| 7    | TCP协议的可靠性如何保证 ||
| 8    | TCP粘包问题                ||
| 9    | 长、短连接                 ||
| 10 | 为什么要超时重试 ||
| 11 | RTT动态计算的作用 ||
| 12 | TCP双方可能的状态有哪些 |Listen监听状态<br>SYN_SENT发送状态<br>Established状态等待发送报文<br>fin_wait_1状态<br>**close_wait状态**<br>fin_wait_2状态<br>**last_ack状态**<br>**time_wait状态**<br>closed状态|



## 详细知识点

#### 1. TCP报文是怎样的  
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/340bfe6be9094116b12ea3f1ed8f0a5c~tplv-k3u1fbpfcp-watermark.image)
-  序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。

- 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。

- 确认ACK：占1位，`仅当ACK=1时，确认号字段才有效`。ACK=0时，确认号无效

- 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。

- 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接

> PS：ACK、SYN和FIN这些大写的单词表示`标志位`，其值要么是1，要么是0；ack、seq小写的单词表示`序号`。
>
> ### 2 TCP和UDP的区别  

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e72ce7f07a3a483087cbab160743699e~tplv-k3u1fbpfcp-watermark.image)   

- UDP比TCP快在哪里
 - UDP要不要握手

### 3. 什么是3次握手

**为什么要握手**  
握手的双方，知道对方ack的起始值，那么两方就知道对面发送了多少字节的报文，自己接收到了多少(每个报文中有偏移量)； 如果出现了丢包or超时，就可以做对应的处理(重发、等待等)，从而保证了稳定性and连续性

**握手的流程**

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f72d9bf3ea047a5b93e326c0b55a184~tplv-k3u1fbpfcp-watermark.image)
- 第1次握手：客户端将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。
- 第2次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。
- 第3次握手：客户端收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给服务器端，服务器端检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。
> 一句话概括，TCP连接握手，握的是啥？  
> **通信双方数据原点的序列号！，即ack**

###  为什么要3次， 2次不行么  
如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。  
### 4. 什么是4次挥手
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ae42b432fe848ff9ecd85b2e91a9341~tplv-k3u1fbpfcp-watermark.image)

### 5.滑动窗口

本质上是为了避免接收方消费不过来分组，而发送方连续发送过多的，导致数据丢失的情况。 

>  在任意时刻，发送方都维持了一个连续的允许发送的帧的序号，称为发送窗口；同时，接收方也维持了一个连续的允许接收的帧的序号，称为接收窗口。发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同


- 思路a: 一个包一个包传  

  - 导致的问题： 吞吐量低
    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f410976351c40d3a598c733c2860104~tplv-k3u1fbpfcp-watermark.image)

- 思路b: 一次发很多包，一次确认很多包  

  - 导致的问题： 你知道接收方一次能接收多少包么?(对方缓冲区大小)
    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e28abf53fcfd4e54af5645e30ccb1c5a~tplv-k3u1fbpfcp-watermark.image)

- 思路c(滑动窗口): 动态调整发送的多少， 对方每接收一些包，发送方的窗口就继续滑动多少包
  ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d75517742904f35aec9be6378732004~tplv-k3u1fbpfcp-watermark.image)

- 思路d: 丢包了怎么办？  
  有可能我们包发过去，对方的Ack丢了。也有可能我们的包并没有发送过去。从发送方角度看就是我们没有收到Ack。  
  一直在等Ack。如果一直等不到的话，我们也会把读进缓存的待发送的包也一起发过去。但是，这个时候我们的窗口已经发满了。所以并不能把12号包读进来，而是始终在等待5号包的Ack。
  ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ea8a471393f4a6f8069e4cfb6bd992c~tplv-k3u1fbpfcp-watermark.image)
  	

- ​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              思路e: 如果一直没有等到ack怎么办?  
  `超时重传` 这里有一点要说明：这个Ack是要按顺序的。必须要等到5的Ack收到，才会把6-11的Ack发送过去。这样就保证了滑动窗口的一个顺序。
   ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b512ddc4181741e094ac7197fdeb73b4~tplv-k3u1fbpfcp-watermark.image)

  > 窗口大小： TCP报文头部里有写，告诉对方我现在可用的容量是多少，你发送的数据必须小于ta
  > 窗口大小一般会随着双方消费能力的变化、网络环境的变化而动态改变

### 6. 拥塞控制

拥塞控制是为了应对网络不佳的情况，防止在网络不佳时，过多的数据注入到网络中，避免出现网络负载越来越大的情况。

- 慢开始、拥塞避免
  - 慢开始：表示拥塞窗口从1开始，每过一个RTT，拥塞窗口加倍，直到窗口大小达到阈值。
  - 拥塞避免: 达到阈值后，使用拥塞避免算法，每过一个RTT，增加1

- 快重传、 快恢复
    - 快重传：要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。
    - 快恢复：当发送方连续收到三个重复确认时，就执行乘法减小算法，把拥塞窗口阈值减半（为了预防网络发生拥塞）。但是接下去并不执行慢开始算法，而是将当前发送的窗口设置为拥塞窗口阈值减半后的值，然后执行拥塞避免算法。

### 7. TCP协议的可靠性如何保证



- **分块传送**：数据被分割成**最合适的**数据块（UDP的数据报长度不变）

  发送大包、长文，总比发送一小块数据，失败概率大得多吧

- **等待确认**：通过定时器等待接收端发送确认请求，收不到确认则重发

  根据墨菲定律，总会失败的，总会丢失的； 怎么办呢？重发呗

- **确认回复**：收到确认后发送确认回复(不是立即发送，通常推迟几分之一秒)

  不确认你咋知道要不要重发，重发几次

- **数据校验**：保持首部和数据的校验和，检测数据传输过程有无变化

- **乱序排序**：接收端能重排序数据，以正确的顺序交给应用端

  应对复杂的网络排队情况

- **重复丢弃**：接收端能丢弃重复的数据包

  重试、重发情况下可能出现，也许对方只是收到数据慢了，而不是丢失了

- **流量缓冲**：两端有固定大小的缓冲区（滑动窗口），防止速度不匹配丢数据

  

- ### 8 粘包

- ### 9 长、短连接



## 参考资料

1. [TCP协议详解](https://juejin.cn/post/6844903685563105293)