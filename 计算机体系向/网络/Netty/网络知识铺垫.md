## 网络知识铺垫
| 序号 | 问题                             | 一句话简介                                                   |
| ---- | -------------------------------- | ------------------------------------------------------------ |
| 0    | IO模型                           | 参考文档 (https://juejin.cn/post/6844904000496599054)<br><br/>阻塞IO (BIO)<br>非阻塞IO (NIO)<br/>IO多路复用<br/>信号驱动IO<br/>异步IO(AIO)<br> |
| 1    | 同步异步 vs 阻塞非阻塞           |                                                              |
| 2    | IO模型的底层原理                 |                                                              |
| 3    | "C10K"问题                       |                                                              |
| 4    | java IO的历史                    | jdk1.4之前是采用同步阻塞模型（BIO）<br>jdk1.4之后推出NIO,支持非阻塞 IO<br>jdk1.7 升级推出 NIO2.0，提供了AIO 功能，支持文件和网络套接字的异步 IO |
| 5    | Netty和Nio的关系                 | java有NIO包去实现非阻塞的网络IO，但NIO包太复杂了，写代码很冗长<br>所以Netty做了封装,使用 Netty可以高效开发，但底层还是使用java NIO的代码 |
| 6    | IO多路复用是什么？ Netty怎么用的 |                                                              |
| 7    | **Reactor 线程模型** 是什么      |                                                              |
| 8    | 零拷贝技术(zero copy)            |                                                              |

### 0.IO模型

- 阻塞IO (BIO)

- 非阻塞IO (NIO)

  用户进程不断轮询，询问内核数据准备好了没有

  缺点: 需要让用户进程不断切换到内核态

- IO多路复用

- 信号驱动IO

- 异步IO(AIO)

前 4 种是同步 IO，在内核数据 copy 到用户空间时是阻塞的。



### 1. 同步异步 vs 阻塞非阻塞

​	**阻塞和非阻塞：**读写没有就绪或者读写没有完成，函数是否要一直等待还是采用轮询；

​	**同步和异步：**同步是读写由应用程序完成。异步是读写由操作系统来完成，并通过回调的机制通知应用程序。

### 2.C10K问题

“C10K”即“client 10k”, 用来指代数量庞大的客户端<br>不到10k的情况下， BIO + 线程池其实性能不差的，<br/>在客户端连接数比较大的情况下， 问题就出现了: 

1. 单个线程占用资源挺多(约1M内存)， 10K就是 10G内存
2. 频繁地创建和销毁代价很大，因为涉及到复杂的系统调用； 即使使用了线程池复用也可能会出现这样的问题
3. 上下文切换会导致CPU负载很高



### 1. IO模型的底层原理

参考文档:

(https://www.zhihu.com/question/32163005)

(https://www.jianshu.com/p/598013bd35d6)



IO模型本质是用户线程的调度策略，底层都是调用系统调用来实现的， 比如:

- select() 

  - 1983年在BSD里面实现的

    >  BSD 代表“Berkeley Software Distribution，伯克利软件套件”, 和Linux类似， 都是免费的，开源的，类Unix系统

  - 原理:  

    1. 使用位图算法bitmap

       - 有一个长度固定为1024的数组，数组中每个元素都是0 or 1，如果是1，就代表该位置映射的fd有读写事件。

       - 比如{1, 2, 3, 5, 7}，在某种hash()算法中，就就标记为"01110101"

    2. 只有内核态能感知到socket的事件， 所以select()就是用户进程将监听的socket对应在bitmap上标记为1，然后传给内核

    3. 内核来轮询bitmap上表示的各个socket，当有读写事件时，将bitmap原封不动的返回给用户进程

  - 优点:  算法消耗内存少

  - 缺点: 

    - 线程不安全，且官方文档中明确表示了
    - select 只能监视1024个链接
    - select 仅仅会返回【有个socket有数据啦！】，但是并不会告诉你哪个socker上有数据，于是你只能自己一个一个的找，在TCP连接数较多的时候，需要遍历，自然性能差
    - 会修改入参的数组， 每次操作完都要全部清0

    

- poll()

  - 1997年实现
  - 原理 ：**poll()**和**select()**是非常相似的, 唯一的区别在于**poll()**摒弃掉了位图算法，使用自定义的结构体**pollfd**
  - 优点: 
    - 去除了1024的限制
    - 不修改入参的数组了
  - 缺点:  仍然线程不安全

- epoll()

  - 2002 年实现
  - 优点:  解决了select()的所有问题
  - 缺点:  只有linux支持， BSD不支持 (BSD上面对应的实现是kqueue).
  - 应用: Nginx、Redis等都广泛地使用了此种模式

  

### 3.IO多路复用是什么？ Netty怎么用的

IO多路复用，英文全称是 **I/O multiplexing**

I/O 是指网络 I /O ，多路指多个 TCP 连接，复用指一个或几个线程。

- 思路:   
  - 使用一个或者几个线程处理多个 TCP 连接，不必创建过多的线程进程，也不必维护这些线程进程。
  - 哪个TCP连接有数据了，当前线程就开始读写这个TCP
  - 底层一般使用epoll()来实现 （当然，select(), poll()也可以）

- 目的： 尽量多的提高服务器的吞吐能力 (因为需要创建的线程少了，减少了CPU和内存的浪费)





<img src="https://pic4.zhimg.com/80/18d8525aceddb840ea4c131002716221_720w.jpg?source=1940ef5c" alt="img" style="zoom: 67%;" />

在同一个线程里面， 通过拨开关的方式，来同时传输多个I/O流， (学过EE的人现在可以站出来义正严辞说这个叫 “时分复用” 了）。



### 4. Reactor**线程模型** 是什么

大家可能会经常听到2种模式：**Reactor和Preactor**

- **Reactor 模式：主动模式。**
- **Preactor 模式：被动模式。**

> Reactor 线程模型基于事件驱动，采用多路复用将事件分发给相应的 Handler 处理，非常适合处理海量 IO 的场景。 

Reactor**线程模型**核心组成部分包括Reactor和线程池，其中Reactor负责监听和分配事件，线程池负责处理事件，而根据Reactor的数量和线程池的数量，又将Reactor分为三种模型:

- 单线程模型 (单Reactor单线程)
- 多线程模型 (单Reactor多线程)
- 主从多线程模型 (多Reactor多线程)



下图是多线程模型

<img src="http://ifeve.com/wp-content/uploads/2019/08/image-4-1024x741.png" alt="img" style="zoom:50%;" />