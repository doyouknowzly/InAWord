# 零拷贝技术



## **什么是拷贝**

要知道零拷贝，需要先知道什么是拷贝。其实这个”拷贝“来自于 Linux 中的标准 I/O 接口的基本数据拷贝的操作，

而这一操作会导致数据在**操作系统内核地址空间**的缓冲区和应用**程序地址空间**定义的缓冲区之间进行传输。



## 为什么需要零拷贝

<img src="https://pic4.zhimg.com/80/v2-28027232e465dd5ee168eeb6da232bdb_720w.jpg" alt="img" style="zoom:67%;" />

如上所述，因为有内核-用户 空间的传输，共产生了**四次数据拷贝**， 又在用户态与内核态也发生了**多次上下文切换**，严重影响效率

而零拷贝主要就是为了解决这种低效率



## 优化思路

事实上零拷贝主要指的是**避免数据拷贝，而非没有拷贝**。大致概括如下：

- 避免操作系统内核缓冲区之间进行数据拷贝操作。
- 避免操作系统内核和用户应用程序地址空间这两者之间进行数据拷贝操作。
- 用户应用程序可以避开操作系统直接访问硬件存储。
- 数据传输尽量让 DMA 来做。
- 避免不必要的系统调用和上下文切换。
- 需要拷贝的数据可以先被缓存起来。
- 对数据进行处理尽量让硬件来做。



事实上，零拷贝的实现方式有很多，目的其实就是为了减少数据拷贝



## Linux实现方式

1. 直接I/O

   应用程序直接访问硬件存储，操作系统内核只是辅助数据传输

   ![img](https://pic2.zhimg.com/80/v2-0c8490cf98d7922379875b82a373436d_720w.jpg)

   

2. mmap()

   应用程序调用了 mmap() 之后，数据会先通过 DMA 拷贝到操作系统内核的缓冲区中去。

   接着，应用程序跟操作系统共享这个缓冲区，这样，操作系统内核和应用程序存储空间就不需要再进行任何的数据拷贝操作。

   ![img](https://pic2.zhimg.com/80/v2-8029f18b02bf537b08ff7bd95ad91ce5_720w.jpg)

3. sendfile()

   利用 DMA 引擎将文件中的数据拷贝到操作系统内核缓冲区中，然后数据被拷贝到与 socket 相关的内核缓冲区中去。

   接下来，DMA 引擎将数据从内核 socket 缓冲区中拷贝到协议引擎中去。

   ![img](https://pic4.zhimg.com/80/v2-d2ee7c46d910c62d3d1b0be64f3f0e57_720w.jpg)

4. 带有DMA收集拷贝功能的sendfile()

   之前我们是把页缓存的数据拷贝到socket缓存中，

   实际上，我们仅仅需要把缓冲区描述符传到 socket 缓冲区，再把数据长度传过去，这样 DMA 控制器直接将页缓存中的数据打包发送到网络中就可以了。

   ![img](https://pic1.zhimg.com/80/v2-244852829e9b22802b2004a22bb7eb18_720w.jpg)

   上图总结为以下 3 步：

   - DMA 从拷贝至内核缓冲区

   - 将数据的位置和长度的信息的描述符增加至内核空间（socket 缓冲区）

   - DMA 将数据从内核拷贝至协议引擎

     

5. splice()

   sendfile 利用了Linux提出的管道缓冲区机制，只适用于将数据从文件拷贝到套接字上，有一方必须是管道设备，因而限定了它的使用范围。

