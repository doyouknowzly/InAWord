# 红黑树

参考文档[<<什么是红黑树>>](https://mp.weixin.qq.com/s/-8JFh5iLr88XA4AJ9mMf6g)

[红黑树深入剖析及Java实现](https://tech.meituan.com/2016/12/02/redblack-tree.html)



## 一、定义



### 红黑树是一种自平衡(不是绝对的平衡)的二叉树， 是最简洁、最常用、性能较好的平衡BST

> 说它不严格是因为它不是严格控制左、右子树高度或节点数之差小于等于1

```java
class  Node<T>{
   public  T value;
   public   Node<T> parent;
   public   boolean isRed;
   public   Node<T> left;
   public   Node<T> right;
}
```



### 约束: 

1. 节点是红色或黑色。
2. 根节点是黑色， 空节点被认为是黑色的。
3. 每个叶子节点都是黑色的空节点（NIL节点）。
4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。



## 二、性能

![image-20210601104858334](D:\Users\80233448\AppData\Roaming\Typora\typora-user-images\image-20210601104858334.png)



![image-20210601121828018](D:\Users\80233448\AppData\Roaming\Typora\typora-user-images\image-20210601121828018.png)

##### Robert Sedgewick, 红黑树的发明人，在《算法（第4版）》 中说过， 红黑树等价于2-3树

- 红黑树为什么综合性能好？ 因为**红黑树利用了缓存**
  - 其中2-节点 等价于普通平衡二叉树的节点
  - **3-节点 本质上是非平衡性的缓存**

当需要再平衡（rebalance）时，增删操作时，2-节点 与 3-节点间 的 转化会吸收不平衡性，减少旋转次数，使再平衡尽快结束。

**在综合条件下，增删操作相当时，数据的随机性强时，3-节点的非平衡性缓冲效果越明显。**





## 三、应用场景

Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等；

各种语言的函数库如Java的TreeMap和TreeSet， 重点是``HashMap`` ，JAVA 8之后也使用了红黑树优化性能



## 四、为什么广泛用红黑树，而不是BST等其他树

- 因为BST会因为插入节点的顺序，导致树倾斜

  - 极端情况下树高为N，二叉查找的思路无法使用，BST就退化成了链表

- 为了防止树倾斜，就需要树能"自平衡"， AVL树和红黑树这两种平衡BST使用比较多

  - AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。

    - 删除的最差情况下，AVL树 需要旋转整条路径的所有节点,  时间复杂度是 O(lgN)

    - 红黑树只需要3次旋转，时间复杂度是O(1)

  - 插入、删除多的场景，使用红黑树更好些； 查询多的场景，使用AVL更好些，原因是AVL平衡性更好，层数更低



## 五、原理思路

在插入、删除节点后，树有可能倾斜，可能需要调整来使得整棵树符合上面的约束，

调整方式有2种 : "变色" 和 "旋转"

> 优先尝试变色，如果变色不能满足要求，再尝试旋转



## 六、细节原理

1. 将新插入的节点标记为红色
2. 如果 X 是根结点(root)，则标记为黑色
3. 如果 X 的 parent 不是黑色，同时 X 也不是 root:

- 3.1 如果 X 的 uncle (叔叔) 是红色

- - 3.1.1 将 parent 和 uncle 标记为黑色
  - 3.1.2 将 grand parent (祖父) 标记为红色
  - 3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3



## 七、课后习题

尝试将[10 70 32 34 13 56 32 56 21 3 62 4 ] 逐个插入到树中，理解红黑树 recolor 和 rotation 的转换规则

