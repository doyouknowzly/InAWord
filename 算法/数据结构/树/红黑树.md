# 红黑树

参考文档[<<什么是红黑树>>](https://mp.weixin.qq.com/s/-8JFh5iLr88XA4AJ9mMf6g)

[红黑树深入剖析及Java实现](https://tech.meituan.com/2016/12/02/redblack-tree.html)

[我画了近百张图来理解红黑树](https://juejin.cn/post/6844904020549730318#comment)



## 一、定义

<img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03bae101f8c99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:80%;" />

### 红黑树是一种自平衡(不是绝对的平衡)的二叉树， 是最简洁、最常用、性能较好的平衡BST

> 说它不严格是因为它不是严格控制左、右子树高度或节点数之差小于等于1

```java
class  Node<T>{
   public  T value;
   public   Node<T> parent;
   public   boolean isRed;
   public   Node<T> left;
   public   Node<T> right;
}
```



### 约束: 

1. 节点是红色或黑色。
2. 根节点是黑色， 空节点被认为是黑色的。
3. 每个叶子节点都是黑色的空节点（NIL节点）。
4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。



> 通过上面的性质 4 和性质 5，其实上保证了没有任何一条路径会比其他路径长出两倍，即尽量去保证大致的平衡。

## 二、性能



![img](https://pic1.zhimg.com/80/v2-3b0dd24fe1bc5e5940cc405233ce1e0e_720w.jpg?source=1940ef5c)



##### Robert Sedgewick, 红黑树的发明人，在《算法（第4版）》 中说过， 红黑树等价于2-3树

- 红黑树为什么综合性能好？ 因为**红黑树利用了缓存**
  - 其中2-节点 等价于普通平衡二叉树的节点
  - **3-节点 本质上是非平衡性的缓存**

当需要再平衡（rebalance）时，增删操作时，2-节点 与 3-节点间 的 转化会吸收不平衡性，减少旋转次数，使再平衡尽快结束。

**在综合条件下，增删操作相当时，数据的随机性强时，3-节点的非平衡性缓冲效果越明显。**





## 三、应用场景

Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等；

各种语言的函数库如Java的 **TreeMap**和TreeSet， 重点是``HashMap`` ，JAVA 8之后也使用了红黑树优化性能



## 四、为什么广泛用红黑树，而不是BST等其他树

- 因为BST会因为插入节点的顺序，导致树倾斜

  - 极端情况下树高为N，二叉查找的思路无法使用，BST就退化成了链表

- 为了防止树倾斜，就需要树能"自平衡"， AVL树和红黑树这两种平衡BST使用比较多

  - AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。

    - 删除的最差情况下，AVL树 需要旋转整条路径的所有节点,  时间复杂度是 O(lgN)

    - 红黑树只需要3次旋转，时间复杂度是O(1)

  - 插入、删除多的场景，使用红黑树更好些； 查询多的场景，使用AVL更好些，原因是AVL平衡性更好，层数更低



## 五、原理思路

参考文章: [红黑树的变色与旋转](https://zhuanlan.zhihu.com/p/102693409)



在插入、删除节点后，树有可能倾斜，可能需要调整来使得整棵树符合上面的约束，

调整方式有2种 : "变色" 和 "旋转"

> 优先尝试变色，如果变色不能满足要求，再尝试旋转



##### 问题: 什么时候变色？

​	如果它的父节点也是红色，违反了rule4，

​	此时如果发现叔节点也是红色，那么将父与叔节点标记为黑色，祖节点为红色，

​    然后把祖节点当作新插入的节点递归重复这一判断，直到根节点



##### 问题: 什么时候知道变色不能解决问题了，需要旋转？

​	当叔节点是黑色，需要做旋转

## 六、操作步骤

1. 将新插入的节点标记为红色
2. 如果 X 是根结点(root)，则标记为黑色
3. 如果 X 的 parent 不是黑色，同时 X 也不是 root:

- 3.1 如果 X 的 uncle (叔叔) 是红色

  - 3.1.1 将 parent 和 uncle 标记为黑色

  - 3.1.2 将 grand parent (祖父) 标记为红色
  - 3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3

- 3.2 如果X 的 uncle (叔叔) 是黑色

  - 需要旋转



## 七、红黑树的插入操作

**一般情况下，红黑树中新插入的节点都是红色的**

为什么呢？

我们从规则5中知道，当前红黑树中从根节点到每个叶子节点的黑色节点数量是一样的，此时假如新的黑色节点的话，必然破坏规则5。

但加入红色节点却不一定,除非其父节点就是红色节点 (此时会破坏规则4) ，因此加入红色节点，破坏规则的可能性小一些。



## 八、旋转操作



### 左旋

逆时针旋转两个节点，让一个节点被其右子节点取代，而该节点成为右子节点的左子节点。

![img](https://user-gold-cdn.xitu.io/2019/12/14/16f03bbc0657efe3?imageslim)

### 右旋

顺时针旋转两个节点，让一个节点被其左子节点取代，而该节点成为左子节点的右子节点。

![img](https://user-gold-cdn.xitu.io/2019/12/14/16f03baf60bf8024?imageslim)



## 课后习题

尝试将[10 70 32 34 13 56 32 56 21 3 62 4 ] 逐个插入到树中，理解红黑树 recolor 和 rotation 的转换规则

