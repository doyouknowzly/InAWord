## 一、Service Mesh定义

参考文章 (https://zhuanlan.zhihu.com/p/61901608)



直译是: 服务网格。

**一言以蔽之：Service Mesh是微服务时代的TCP协议**

> 将它比作是应用程序或者说微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控等

**Service Mesh基本没有新的功能，做的都是spring cloud做过的事情**，不过优点在于: 

1. 云原生
2. 跨语言
3. 目标是TCP协议，不是框架。所以上层应用无感



第二代微服务模式看似完美，但开发人员很快又发现，它也存在一些本质问题：

- 其一，虽然框架本身屏蔽了分布式系统通信的一些通用功能实现细节，但开发者却要花更多精力去掌握和管理复杂的框架本身，在实际应用中，去追踪和解决框架出现的问题也绝非易事；
- 其二，开发框架通常只支持一种或几种特定的语言，回过头来看文章最开始对微服务的定义，一个重要的特性就是语言无关，但那些没有框架支持的语言编写的服务，很难融入面向微服务的架构体系，想因地制宜的用多种语言实现架构体系中的不同模块也很难做到；
- 其三，框架以lib库的形式和服务联编，复杂项目依赖时的库版本兼容问题非常棘手，同时，框架库的升级也无法对服务透明，服务会因为和业务无关的lib库升级而被迫升级；

因此以Linkerd，Envoy，NginxMesh为代表的代理模式（边车模式）应运而生，这就是第一代Service Mesh，它将分布式服务的通信抽象为单独一层，在这一层中实现负载均衡、服务发现、认证授权、监控追踪、流量控制等分布式系统所需要的功能，作为一个和服务对等的代理服务，和服务部署在一起，接管服务的流量，通过代理之间的通信间接完成服务之间的通信请求，这样上边所说的三个问题也迎刃而解。

![img](https://pic2.zhimg.com/80/v2-e5660d35a311467c3323f10ebf2fb9a5_720w.jpg)

如果我们从一个全局视角来看，就会得到如下部署图：

![img](https://pic4.zhimg.com/80/v2-8a9cc161a34d97f36ead06d0abc5b1fb_720w.jpg)

如果我们暂时略去服务，只看Service Mesh的单机组件组成的网络：

![img](https://pic2.zhimg.com/80/v2-ee0bde35f9ec79bf38feda98550b8f71_720w.jpg)