# 授权码类型

在这个类型中，访问令牌是通过授权码换来的。

> 授权码code 值对应的 key 是 app_id 和 user 的组合值，即不同应用间的授权码肯定不一样



> 1.按照什么规则来生成访问令牌 access_token 的值，OAuth 2.0 规范中并没有明确规定，但必须符合三个原则：唯一性、不连续性、不可猜性
>
> 2.和授权码 code 值一样，我们需要将访问令牌 access_token 值存储起来，并将其与第三方软件的应用标识 app_id 和资源拥有者标识 user 进行关系映射。也就是说，一个访问令牌 access_token 表示某一个用户给某一个第三方软件进行授权
>
> 3.同时，授权服务还需要将授权范围跟访问令牌 access_token 做绑定。最后，还需要为该访问令牌设置一个过期时间 expires_in，比如 1 天





到这里估计你会问了，==为什么要用授权码来换令牌？为什么不能直接颁发访问令牌呢？==







## 流程图示例

![img](https://static001.geekbang.org/resource/image/96/32/96973a6f5637fb3d1049f6d456702932.png)





从图中看到，在第 4 步授权服务生成了授权码 code，按照一开始我们提出来的问题，如果不要授权码，这一步实际上就可以直接返回访问令牌 access_token 了。

按着这个没有授权码的思路继续想，如果这里直接返回访问令牌，那我们肯定不能使用==重定向==的方式。因为这样会把==安全保密性要求极高==的访问令牌暴露在浏览器上，从而将会面临访问令牌失窃的安全风险。

显然，这是不能被允许的。也就是说，如果没有授权码的话，我们就只能把访问令牌发送给第三方软件小兔的==后端服务==





按照这样的逻辑，上面的流程图就会变成下面这样：

![img](https://static001.geekbang.org/resource/image/f4/33/f44866070ee06bc3fcceac792570d433.png)

如果没有授权码，直接把访问令牌发送给第三方软件小兔的后端服务到这里，看起来天衣无缝。

小明访问小兔软件，小兔软件说要打单你得给我授权，不然京东不干，然后小兔软件就引导小明跳转到了京东的授权服务。到授权服务之后，京东商家开放平台验证了小兔的合法性以及小明的登录状态后，生成了授权页面。紧接着，小明赶紧点击同意授权，这时候，京东商家开放平台知道可以把小明的订单数据给小兔软件。于是，京东商家开放平台没含糊，赶紧生成访问令牌 access_token，并且通过后端服务的方式返回给了小兔软件。

这时候，小兔软件就能正常工作了。这样，问题就来了，什么问题呢？当小明被浏览器重定向到授权服务上之后，小明跟小兔软件之间的 ==“连接” 就断了==，相当于此时此刻小明跟授权服务建立了“连接”后，将一直“停留在授权服务的页面上”。

你会看到图 2 中问号处的时序上，小明再也没有重新“连接”到小兔软件。但是，这个时候小兔软件已经拿到了小明授权之后的访问令牌，也使用访问令牌获取到了小明店铺里的订单数据。

这时，考虑到“小明的感受”，小兔软件应该要通知到小明，但是如何做呢？现在==“连接断了”==，这事儿恐怕就没那么容易了。OK，为了让小兔软件能很容易地通知到小明，还必须让小明跟小兔软件重新建立起 “连接”。这就是我们看到的第二次重定向，小明授权之后，又重新重定向回到了小兔软件的地址上，这样小明就跟小兔软件有了新的 “连接”。到这里，你就能理解在授权码许可的流程中，为什么需要==两次重定向==了吧。



## 间接通信

间接通信我们先分析下为什么是“间接”。我们把图 1 中获取授权码 code 的流程 “放大”，并换个角度来看一看，也就是将浏览器这个代理放到第三方软件小兔和授权服务中间。于是，我们来到了下面这张图：

![img](https://static001.geekbang.org/resource/image/9e/bf/9e4f51f1f77840bd0b8f756be40d42bf.jpg)

不知道你注意到没有，第三方软件小兔和授权服务之间，并没有发生直接的通信，而是通过浏览器这个“中间人” 来 “搭线”的。因此，我们说这是一个间接通信的方式。



## 直接通信

那我们再分析下，授权码换取访问令牌的交互，为什么是“直接”的。我们再把图 1 中获取访问令牌的流程“放大”，就得到了下面的图示：

![img](https://static001.geekbang.org/resource/image/84/9b/84dc2d6f578b6968b782a0280a73be9b.png)

相比获取授权码过程的间接通信，获取访问令牌的直接通信就比较容易理解了，就是第三方软件小兔获取到授权码 code 值后，向授权服务发起获取访问令牌 access_token 的通信请求。

这个请求是第三方软件服务器跟授权服务的服务器之间的通信，都是在后端服务器之间的请求和响应，因此也叫作==后端通信==



> 为什么后端通信比前端通信安全？
>
> 因为后端通信可以使用私钥进行加密，而前端没法使用私钥，因为前端私钥很容易被反编译破解





## 直接通信的流程细节

在授权码许可类型中，授权服务的工作，可以划分为两大部分，一个是颁发授权码 code，一个是颁发访问令牌 access_token。为了更能表达授权码和访问令牌的存在，我在图中用深色将其标注了出来：

![img](https://static001.geekbang.org/resource/image/a5/11/a5d231c5b356ecf2031yy7d17207c011.png)



在生成了授权码 code 之后，我们也按照上面所述绑定了响应的映射关系。

这时，你还记得我之前讲到的授权码是临时的、一次性凭证吗？因此，我们还需要为 code 设置一个有效期。

OAuth 2.0 规范建议授权码 code 值有效期为 10 分钟，并且一个授权码 code 只能被使用一次。不过根据经验呢，在生产环境中 code 的有效期一般不会超过 5 分钟

