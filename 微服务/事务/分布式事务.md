# 分布式事务



## 一、什么是分布式事务

事务: 一个完整的操作，由N个小操作完成，且必须一起成功or一起失败

分布式事务: 这N个小操作，分布在多个服务器进程之间



遇到的问题: 出现多进程间的 网络传输，而网络传输又是复杂的、不稳定的 (比如， 没有响应到底是超时了or失败了or没收到)

> 分布式事务几乎满足不了 ACID。
>
> 当然，其实对于单机事务而言大部分情况下也没有满足 ACID



## 二、何时需要分布式事务



需要事务，但是MySQL的事务又不能满足时:

​	跨库、跨进程等情况



不过，需要提醒的是 : 业务上，**尽量避免分布式事务**

## 三、别人的思路

Cassandra、Dynamo 等，默认优先选择AP，弱化C；HBase、MongoDB 等，默认优先选择CP，弱化A



大部分人使用的都是最终一致性方案，即都存在短暂的数据不一致， 损失了一定的Consistency（一致性）

## 四、解决方案1.TCC

1. Try, Confirm, Cancel

   TCC 要求每个分支事务实现三个操作：预处理 Try、确认 Conﬁrm、撤销 Cancel.

   - Try 阶段是做完业务检查（一致性）及资源预留（隔离），此阶段仅是一个初步操作，它和后续的 Conﬁrm 一起才能真正构成一个完整的业务逻辑。
   - Confirm 阶段是做确认提交，Try 阶段所有分支事务执行成功后开始执行 Conﬁrm。通常情况下，采用 TCC 则认为 Conﬁrm 阶段是不会出错的。
     即：只要 Try 成功，Conﬁrm 一定成功。若 Conﬁrm 阶段真的出错了，需引入重试机制或人工处理。
   - Cancel 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用 TCC 则认为 Cancel 阶段也是一定成功的。
     若 Cancel 阶段真的出错了，需引入重试机制或人工处理。

2. 需要注意3种异常处理: **空回滚**、**幂等**、**悬挂**

  **空回滚**

  在没有调用 TCC 资源 Try 方法的情况下，调用了二阶段的 Cancel 方法，Cancel 方法需要识别出这是一个空回滚，然后直接返回成功。

​		**幂等**

​		通过前面介绍已经了解到，为了保证 TCC 二阶段提交重试机制不会引发数据不一致，要求 TCC 的二阶段 Try、Conﬁrm 和 Cancel 接口保证幂等，这样不会重		复使用或者释放资源。如果幂等控制没有做好，很有可能导致数据不一致等严重问题。

​		**悬挂**

​		悬挂就是对于一个分布式事务，其二阶段 Cancel 接口比 Try 接口先执行。

3. 总结 : TCC实现起来比较复杂，业务的侵入性也极强；但优点在于，粒度可控，比较灵活



## 五、解决方案2.MQ事务

参考 : [事务消息](../../中间件/RocketMQ/事务消息)



## 六、解决方案3. 最大努力通知





## 七、方案总结对比

|            | 2PC      | TCC        | 可靠消息   | 最大努力通知 |
| ---------- | -------- | ---------- | ---------- | ------------ |
| 一致性     | 强一致性 | 最终一致性 | 最终一致性 | 最终一致性   |
| 吞吐量     | 低       | 中         | 高         | 高           |
| 实现复杂度 | 易       | 难         | 中         | 易           |
