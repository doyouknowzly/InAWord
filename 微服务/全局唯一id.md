# 全局唯一ID



生成策略一般如下:

### 一、使用数据库的auto_increment



### 二、UUID

参考文档 [UUID如何保证唯一性？](https://zhuanlan.zhihu.com/p/70375430)

**定义 **: 

​	UUID(Universally Unique IDentifier)， 是一个128位数字的唯一标识

​	UUID使用16进制表示，共有36个字符(32个字母数字+4个连接符"-")，格式为`8-4-4-4-12`，如：

```powershell
6d25a684-9558-11e9-aa94-efccd7a0659b
xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
```

​	上面的字母是用的16进制，一个16进制只代表4个bit，所以总共是(8+4+4+4+12)*4=128位。

> UUID现有5种版本，有各自的实现逻辑。版本是根据不同的使用场景划分的，而不是根据精度，所以Version5并不会比Version1精度高，
>
> 在精度上，**大家都能保证唯一性，重复的概率近乎于0**。

**优点** : 

- 不用远程调用，本地即可生成
- 基本可以认为没有上限，不需要扩容

**缺点** :

- 无法保证单调递增
- uuid过长，往往用字符串表示，**作为主键建立索引查询效率低**
  - 常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）

### 三、取本地的ms数

**优点**:

- 本地生成ID，不需要进行远程调用，时延低
- 生成的ID趋势递增

**缺点**:

- 并发的情况下，容易产生冲突

  - 可以再 + 一个随机数，避免冲突 (和SnowFlake算法思想是类似的)

- 如果本地时间不准，就很有可能冲突和非递增

  

### 四、使用Redis生成

因为Redis是单线程的，性能又好，所以可以	用Redis的原子操作 **INCR** 和 **INCRBY** 来实现



### 五、Twitter开源的SnowFlake算法

snowflake 是 twitter 开源的分布式ID生成算法，其核心思想为，一个long型的ID：

- 41 bit 作为毫秒数 - **41位的长度可以使用69年**
- 10 bit 作为机器编号 （5个bit是数据中心，5个bit的机器ID） - **10位的长度最多支持部署1024个节点**
- 12 bit 作为毫秒内序列号 - **12位的计数顺序号支持每个节点每毫秒产生4096个ID序号**

![img](https://img-blog.csdnimg.cn/20190726091202771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTg3NzE=,size_16,color_FFFFFF,t_70)



Snowflake 工程化之后，会有两种实现方式：

- 嵌入业务代码，也就是分布在业务服务器中，这种方案的好处是业务代码在使用的时候不需要网络调用，性能会比较好，但是这样有个问题， 随着业务服务器的数量变多，很难保证机器 ID 的唯一性。有的方案是采用 数据库自增id ,或者 zookeeper获取唯一的机器ID。
- 另外一个部署方式是将信号发生器作为独立的服务部署，业务使用信号发生的时候需要多一次网络调用，存在对内网调用性能的损耗，发号器部署实例是有限的，一般可以将机器 ID卸载配置文件里，这样可以保证机器 ID的唯一性。通常单实例单 CPU 可以达到两万每秒。

