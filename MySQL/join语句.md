# 五、join 语句

| 序号 | <span style="display:inline-block;width:160px"> 问题 </span> | 一句话解释                                                   | 详细知识点                                                   |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 0    | join关联查询有哪些，使用场景？                               | 有**innner join** (inner join = join),<br>**straight join**    (功能同join类似，但能让左边的表来驱动右边的表, 能change优化器对于联表查询的执行顺序); <br>select * from t1 straight_join t2 on (t1.a=t2.a); <br>**left join** ;<br>**right join**；<br> 其中内连接包括隐式内连接（where a.id = b.id）， 显式内连接(inner join, straight join); 外连接包括left join, right join<br> MySQL 认为任何一个查询都是一次 “关联”，就算是单表查询也是"关联"<br> | [<<MySQL指引（四）：join关联查询底层原理（上）>>](https://blog.csdn.net/zhou307/article/details/104158664) |
| 1    | join的底层原理                                               | MySQL优化器给出执行计划，然后执行引擎根据计划来执行。也就是优化器给出代码，执行引擎运行代码。<br>所以，这里的关联查询底层原理实际就是看 优化器 给出的执行计划是什么。<br> | 1. [极客时间<<到底可不可以使用join>>？](https://time.geekbang.org/column/article/79700) <br>2. [<<MySQL指引（五）：join关联查询底层原理（下）>>](https://oatlmy.blog.csdn.net/article/details/104172743)\| |
| 2    | 为什么很多DBA不建议使用join语句                              | 如果可以使用 Index Nested-Loop Join 算法，也就是说可以用上被驱动表上的索引，其实是没问题的；<br>如果使用 Block Nested-Loop Join 算法，扫描行数就会过多。尤其是在大表上的 join 操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种 join 尽量不要用。 |                                                              |
| 3    | 什么是小表                                                   | 两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表” |                                                              |
| 4    | 为什么要小表驱动大表                                         | 结论:无论是Block还是Index，都是小表驱动大表的效率更高 <br> 假设小表的行数是 N，大表的行数是 M。<br>一、无论是哪种算法，两个表都要做一次全表扫描，所以**总的扫描行数**是 `` M+N ``；内存中的**判断次数是  ```M*N ```**。从这个维度看，M和N的大小互换，是不影响性能的 <br> 二、假设一个buffer_size的大小不够加载2张表的数据，只能分段加载，假设，驱动表的数据行数是 N，需要分 K 段才能完成算法流程，被驱动表的数据行数是 M。注意，这里的 K 不是常数，N 越大 K 就会越大，因此把 K 表示为 ``λ*N ``， 显然λ的取值范围是 (0,1)。所以，在这个算法的执行过程中：扫描行数是  ``N+λ*N*M ``；内存判断 ```N*M ``` 次。  <br> **显然，N 小一些，整个算式的结果会更小** <br> 当然λ作为系数才是影响范围更大的，所以如果可以的话，buffer size越大越好，这样 λ就会很小。 |                                                              |
| 5    | BKA 算法                                                     |                                                              |                                                              |

## 详细知识点阐述  

### 1.join的底层原理

MySQL优化器给出执行计划，然后执行引擎根据计划来执行。也就是优化器给出代码，执行引擎运行代码。
所以，这里的关联查询底层原理实际就是看 优化器 给出的执行计划是什么。

> 驱动表的概念:
> MySQL中指定了连接条件时，满足查询条件的记录行数少的表为驱动表；如未指定查询条件，则扫描行数少的为驱动表。MySQL默认的优化器就是这么粗暴地，以小表驱动大表的方式来决定执行顺序的。<br>

  

**join算法**的执行计划有以下几种：

- 1. Simple Nested-Loop Join **MySQL没有使用，因为太慢了，这里只是介绍**  每条驱动表t1的数据，都要去全表扫描被驱动表1次， 时间复杂度 = O(Nt1 * Nt2)
- 2. Index Nested-Loop Join 使用被驱动表的索引，选择和匹配是走的磁盘里的索引文件
- 3. Block Nested-Loop Join :在被驱动表**没有用到索引**的时候，使用这个算法。<br>使用join buffer，把数据**分块**读到内存中再比较是否符合where条件， join buffer的size默认是256K<br>时间复杂度和Simple是一样的，但是因为放到内存中，耗时更短<br>**但相比index差距还是很大，还是要尽量避免Block的** 
- 4. Hash Join MySQL 8.0加入，还没看