# *从范围上来看:*



## 一、行锁

1. 实现方式: 

   - Record Lock : 单个行记录上加锁 (**本质就是锁住当前的索引节点**， 如果没有索引，就隐式使用主键索引)
   - Gap Lock: 间隙锁，锁定一个范围，但不包括某条记录本身
   - Next-Key Lock: 上两个锁的和， 既包括范围，又包括记录自己 (包含的范围 : 当前索引-->下一个值之间的范围)

   

2. **当查询的索引含有唯一属性时，InnoDB引擎会优化，将Next-Key降级为Record ** (因为就一条，没必要搞范围锁)

3. 同一条SQL， 不同索引文件之间，**锁住的行是一致的**，但可能用的索引方式不一样 (比如主键索引用record, 辅助索引用next-key)

   - 注意： 只会锁住主键索引 和 某一个辅助索引， 假设表由4个单独的辅助索引（而不是联合索引），where条件里也都带了，也只会由MySQL优化器选择1个索引， 又因为会**回表**,  才会又锁住主键索引

4. **特别需要注意的是**:  除了当前索引值外，InnoDB引擎还会对**索引**的**下一个**键值加上gap lock，形成next-key lock

   目的 : 为了防止幻读(Phantom)问题 

   > 幻读: 连续两次的select 结果不一样， 违反了事务的隔离性原则

   处理思路： 

   - 假设数据库中有， 1，10两条记录，
   - select * from  table where id > 5,  可以查出来10这一条记录
   - 假设不使用next -key,  而只对索引=5的record单行加锁
   - 如果有事务新增了 id = 7 (锁只在id=5, 所以可以正常写入)
   - 下次select * from  table where id > 5， 就会查出7,10两天记录
   - 所以要锁**一个范围**

5. 实现原理: 

   

   

## 二、表锁





## 三、页锁 