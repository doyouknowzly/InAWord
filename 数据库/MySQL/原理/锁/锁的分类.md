# 锁的分类



## 零、何时加锁？



**InnoDB会根据隔离级别，在需要的时候自动加锁 (隐式)**

- 默认repeatable read（可重复读）的级别下， 使用Next-Key方式实现行锁

另外，InnoDB也支持通过特定语句进行显示加锁 (尽管下面的SQL不符合SQL规范) ：

- SELECT *** LOCK IN SHARE MODE

- SELECT *** FOR UPDATE

- LOCK TABLES (尽量不要使用， 大部分情况下，InnoDB的行级锁比表级锁性能好很多)

  

# *从类型上来看:*



## 一、Lock和Latch

这里要区分锁中容易令人混淆的概念lock与latch。在数据库中，lock与latch都可以成为锁，但两者有截然不同的含义

![img](https://images2015.cnblogs.com/blog/754297/201601/754297-20160131225332443-857830570.jpg)

Latch是瞬间的占用，释放，没有死锁检测机制，也不会死锁 (线程等就完事)； 一般是MySQL处理数据结构的临界资源要用到， **日常使用中不会感知到Latch**

Lock的释放需要等到事务结束(commit or rollback)，他占用的时间长短由事务大小决定, **本文主要关注Lock**



## 二、共享锁vs排他锁

1. 释放条件: 

	- 锁只有在执行commit或者rollback的时候才会释放, 并且所有的锁都是在**同一时刻**被释放。

2. 共享锁：

	- 别名 【读锁】、【s锁】(Shared)
	- 其他事务可以读，但不能写， 即【读读可以并行】
	- 加锁的条件:

		- 显式声明  :  SELECT *** LOCK IN SHARE MODE
		- **普通的select语句不加任何锁**

3. 排他锁 ：

	- 别名【写锁】、【x锁】(Exclusive)
	- 其他事务不能读取，也不能写，即【写读，写写不可以并行】
	- 加锁的条件: 
		- 对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB会自动给涉及数据集加排他锁（X)
		- 显式声明  : SELECT *** FOR UPDATE （此时select 就等同一个update语句）






## 三、 意向锁

> 意向锁的意思是，事务希望能够在更细的粒度加锁。事务在加行锁前，必须先获得粗粒度的锁，比如意向锁

为了允许**行锁和表锁共存**，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），InnoDB的设计比较简单，**意向锁即是表锁**

- 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
- 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。

![img](https://pic4.zhimg.com/80/v2-37761612ead11ddc3762a4c20ddab3f3_720w.jpg)

如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。

------



# *从范围上来看:*

## 四、行锁

1. 实现方式: 

   - Record Lock : 单个行记录上加锁 (**本质就是锁住当前的索引节点**， 如果没有索引，就隐式使用主键索引)
   - Gap Lock: 间隙锁，锁定一个范围，但不包括某条记录本身
   - Next-Key Lock: 上两个锁的和， 既包括范围，又包括记录自己 (包含的范围 : 当前索引-->下一个值之间的范围)

   

2. **当查询的索引含有唯一属性时，InnoDB引擎会优化，将Next-Key降级为Record ** (因为就一条，没必要搞范围锁)

3. 同一条SQL， 不同索引文件之间，**锁住的行是一致的**，但可能用的索引方式不一样 (比如主键索引用record, 辅助索引用next-key)

4. **特别需要注意的是**:  除了当前索引值外，InnoDB引擎还会对**索引**的**下一个**键值加上gap lock，形成next-key lock

   目的 : 为了防止幻读(Phantom)问题 

   > 幻读: 连续两次的select 结果不一样， 违反了事务的隔离性原则

   处理思路： 

   - 假设数据库中有， 1，10两条记录，
   - select * from  table where id > 5,  可以查出来10这一条记录
   - 假设不使用next -key,  而只对索引=5的record单行加锁
   - 如果有事务新增了 id = 7 (锁只在id=5, 所以可以正常写入)
   - 下次select * from  table where id > 5， 就会查出7,10两天记录
   - 所以要锁**一个范围**

5. 实现原理: 

   

   

## 五、表锁



## 六、页锁 