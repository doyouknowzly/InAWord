---
typora-root-url: ..\..\..\..\resource\img
---

# 事务

**MySQL默认采用自动提交(autocommit)模式。这就表示除非显式地开始一个事务，否则每个查询都被当做一个单独的事务自动执行**



| 序号 | 问题                              | 一句话解释                                                   | 详细知识点                                                   |
| ---- | --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 0    | 事务隔离级别                      | 下面的隔离级别，从上往下**越来越严，性能越来越差**<br> 一、读未提交（read uncommitted）<br>二、读提交（read committed）<br>三、可重复读（repeatable read）(innodb默认)<br>四、串行化（serializable ） | [三歪连MVCC和事务隔离级别的关系](https://mp.weixin.qq.com/s/0-YEqTMd0OaIhW99WqavgQ) |
| 1    | 事务的隔离级别的原理              |                                                              |                                                              |
| 2    | MVCC是什么？和事务隔离级别的关系? | 在查询同一条记录的时候，不同时刻启动的事务会有不同的 read-view。<br>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC），由undo log实现 |                                                              |
| 3    | MySQL如何实现事务的               | 隔离性由锁来实现；一致性由undo log来实现；原子性、持久性由redo log来实现 |                                                              |
| 4    | 事务的分类                        | 扁平事务<br>带有保存点的扁平事务<br>链事务<br>嵌套事务<br>分布式事务 |                                                              |





## 0.事务的隔离级别

### 0.1 须知，**隔离级别越高，性能就越差** 

所以我们大多数时候是在性能和数据一致性之间找一个平衡，根据业务的要求而定。

下面的隔离级别，从上往下**越来越严，性能越来越差**

1. 读未提交（read uncommitted）

   一个事务可以读到另一个未提交事务修改过的数据

   原理 : 直接返回，不额外处理

2. 读提交（read committed）

   一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值

   原理 : **视图**，每个SQL执行的时候创建的视图

3. 可重复读（repeatable read）

   在一些业务场景中，一个事务只能读到另一个已经提交的事务修改过的数据，但是第一次读过某条记录后，即使其他事务修改了该记录的值并且提交，该事务之后再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据

   原理 : **视图**， 事务启动时创建的**唯一的**一个视图

4. 串行化（serializable ）

   以上3种隔离级别都允许对同一条记录进行`读-读`、`读-写`、`写-读`的并发操作，如果我们不允许`读-写`、`写-读`的并发操作，可以使用`SERIALIZABLE`隔离级别

   原理 : 读写锁，后来的线程需要等待



### 0.2 不同事务级别会导致的问题

(x代表不会出现，Y代表会)

| 隔离级别                     | 第一类丢失更新 | 第二类丢失更新 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | -------------- | -------------- | ---- | ---------- | ---- |
| SERIALIZABLE （串行化）      | X              | X              | X    | X          | X    |
| REPEATABLE READ（可重复读）  | X              | X              | X    | X          | Y    |
| READ COMMITTED （读已提交）  | X              | Y              | X    | Y          | Y    |
| READ UNCOMMITTED（读未提交） | X              | Y              | Y    | Y          | Y    |

**注意， 在REPEATABLE READ（可重复读）** 的隔离级别下，InnoDB引擎通过Next-Key锁的实现，避免了幻读问题

参考 [锁的分类](../锁/锁的分类)

> InnoDB牛逼！ 在可重复读的级别下，达到了串行化的隔离要求



### 0.3 并发事务会导致的问题详解

1. 第一类丢失更新
   - 定义：A事务撤销时，把已经提交的B事务的更新数据覆盖了。
   - 解决方式 : 使用排他X锁
2. 第二类丢失更新
   - 定义：A事务提交时，把已经提交的B事务的更新数据覆盖了。
   - 解决方式 : 使用排他X锁 
     - select语句附带 select *** for update
   
   > 丢失更新，几乎所有的数据库，所有的隔离级别，都能避免丢失更新的情况出现。
   >
   > 但， 业务上的丢失更新很难避免， 比如两个进程，各自读到了自己的内存，过一段时间后update，
   >
   > 就会出现 这种 **"业务上的丢失更新"**
3. 脏读
   - 定义：读到未commit的数据
4. 不可重复读
   - 定义：不会读到未commit的数据，但一个事务范围内两个相同的查询却返回了不同数据。(还是被其他事务的commit的数据影响了)
5. 幻读
   - 范围读时，读到已commit的**插入**数据。



> 幻读vs不可重复读， 区别主要是  **范围查询vs等值查询**, **insert 和 update**

- 不可重复读是 ， where age = 10， 第一次是 张三, 第二次是李四
- 幻读是， where age < 10, 第一次有2条记录，第二次有3条记录，且新增的这条是其他事务commit的



## 1. 事务的隔离级别原理

### 1.1 串行化

> 因为InnoDB在REPEATABLE READ（可重复读）的情况下就能避免幻读，所以本地事务基本不用串行化的级别，一般是分布式事务使用

串行化的情况下，InnoDB引擎会给每个select 语句自动加上 lock in share mode, 即为每个读操作加一个共享锁 (s锁)。

### 1.2 可重复读

可重读读和已提交读，都使用**MVCC**来实现

### 1.3 已提交读

和可重复读的区别在于，生成ReadView的时机不同

- REPEATABLE READ 

  在第一次读取数据时生成一个ReadView

- READ COMMITTD

  在每一次进行普通SELECT操作前都会生成一个ReadView

### 1.4 未提交读

对于使用`READ UNCOMMITTED`隔离级别的事务来说，直接读取记录的最新版本就好了，什么额外的操作都不用做



## 2.MVCC是什么

MVCC(Multi-Version Concurrency Control)即多版本并发控制, **只适用于Msyql隔离级别中的读已提交(Read committed)和可重复读(Repeatable Read)**。

> Read uncommitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC

**MVCC**使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能。



### 2.1 原理

MySQL的行记录，除了存储用户定义的列之外，还有2-3个额外的隐藏列 

- 如果没有显式指定主键，会有row_id
- 6字节的事务ID
- 7字节的回滚指针 (undo log)

每次对记录进行改动，都会记录一条`undo日志`，每条`undo日志`也都有一个`roll_pointer`属性（`INSERT`操作对应的`undo日志`没有该属性，因为该记录并没有更早的版本），可以将这些`undo日志`都连起来，串成一个链表，所以现在的情况就像下图一样：

![image_1d6vfrv111j4guetptcts1qgp40.png-57.1kB](https://user-gold-cdn.xitu.io/2019/3/27/169bf198524e1b34?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

还有一个核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。

所以设计`InnoDB`的大叔提出了一个`ReadView`的概念，这个`ReadView`中主要包含当前系统中还有**哪些活跃的读写事务**，把它们的事务id放到一个列表中，我们把这个列表命名为为`m_ids`。这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

1. 如果被访问版本的`trx_id`属性值（隐藏的列，意思是事务ID）小于`m_ids`列表中最小的事务id，表明生成该版本的事务在生成`ReadView`前已经提交，所以该版本可以被当前事务访问。
2. 如果被访问版本的`trx_id`属性值大于`m_ids`列表中最大的事务id，表明生成该版本的事务在生成`ReadView`后才生成，所以该版本不可以被当前事务访问。
3. 如果被访问版本的`trx_id`属性值在`m_ids`列表中最大的事务id和最小事务id之间，那就需要判断一下`trx_id`属性值是不是在`m_ids`列表中，如果在，说明创建`ReadView`时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建`ReadView`时生成该版本的事务已经被提交，该版本可以被访问。



如果某个版本的数据对当前事务不可见的话，那就 **顺着版本链找到下一个版本的数据**，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本，如果最后一个版本也不可见的话，那么就意味着该条记录对该事务不可见，查询结果就不包含该记录。

### 2.3 优缺点

MVCC在大多数情况下代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。

缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作。



## 3.MySQL如何实现事务的？



ACID参见 [事务基础](../../../微服务/事务/事务基础)

1. 原子性（**A**tomicity）

   **如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行回滚**

   MySQL通过**回滚日志（undo log）** 实现回滚操作

   > 所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 **回滚日志** 中的信息将数据回滚到修改之前的样子即可

   **undo会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚之前未完成的事务。**

2. 隔离性（**I**solation）

   通过 行锁next-key lock实现, 参考 [锁的分类](../锁/锁的分类)

3. 持久性（**D**urability）

   **要实现持久性，就是要在事务提交时，就保证一定落到磁盘了**

   MySQL是通过InnoDb引擎的redo log来 实现持久性的， 当事务提交的时候，会将`redo log`日志进行刷盘

   > redo log频繁刷盘会不会影响性能？ 参考[redoLog](../log/redoLog)

4. 一致性（**C**onsistency）

   一致性是结果，通过保证AID来保证C




## 4.事务的分类

1. 扁平事务

   - 事务类型中最简单的一种，也是最常用的，

   - 由BEGIN WORK 开始， COMMIT WORK/ ROLLBACK WORK 结束

2. 带有保存点的扁平事务

   允许在事务执行过程中，回滚到同一事务中较早的一个状态 ，类似于"回滚一半"的概念

   > 某些业务情况下，放弃并回滚整个事务不合要求，成本也较高

3. 链事务

   - n个事务之间串联，2能看到事务1的结果； 回滚只能回滚当前事务，比如3；

   - 确定3没问题之后，再往下继续执行事务

4. 嵌套事务 (InnoDB不支持)

   - 父事务包含很多子事务， 子事务既可以是扁平的，也可以是带有保存点的，甚至可以是嵌套的

   - 子事务仅保留ACI特性，不保证D

5. 分布式事务