# MySQL日志

| 序号 | 问题              | 一句话解释                                                   |
| ---- | ----------------- | ------------------------------------------------------------ |
| 0    | MySQL的架构分层   | 客户端;<br>连接器、缓存层、分析器、优化器、执行器;<br>存储引擎层 |
| 1    | MySQL的日志有哪些 | **常用**: 重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog） <br>**不常用**: 错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log） |
| 2    | 如何异常恢复      | 只要binlog和redo log能持久化到磁盘，就不怕数据丢失，重启就能恢复。<br>其中，binlog是负责普通数据<br>redo log负责保证事务数据的一致性 |

### MySQL的架构分层
- 1.客户端，我们自己的服务
- 2.连接器，包括授权认证、连接处理等；
- 3.缓存层，如果命中内存就直接返回了，不用查文件系统. 但查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。<br>**注意: MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了** 
- 4.分析器，有点像编译器的分词器，进行词法分析、语法分析
- 5.优化器，执行计划的生成，选择合适的索引等 
- 6.执行器，操作API，返回结果
- 7.存储引擎层，去实现MySQL的Api, 但不解析Sql。比如InnoDb和MyISAM其中，除了引擎层，其他的都属于Server层  



## MySQL日志的对比

| 日志| 别名 | 作用| 内容    | 存储 | 适用场景 |
| -------- | ---------- | :--------------------------------------------- | ------------------------------------------------------------ | ---- | ------------------------------------ |
| binlog   | 二进制日志 | 记录了所有数据的**变更**          | 简单理解就是sql本身，读sql不记录<br>  | **逻辑格式** | 主从复制、数据恢复(某一刻)、集群同步 |
| redo log | 重做日志   | 确保事务的**持久性**                    | 记录的是物理数据页面的修改的信息，不管事务是否提交都会记录下来 | **物理格式** | 事务的崩溃恢复                       |
| undo log | 回滚日志   | 保证事务的**原子性**<br>提供多版本并发控制下的读（MVCC），也即非锁定读 | 除了记录版本，**还记录着sql的回滚sql**，比如1条insert,也会同时有1条delete | **逻辑格式** | 事务回滚                             |

> 物理日志: 记录的是磁盘一整页的数据
>
> 逻辑日志: client使用的日志，结构已经SQL化了

## 详细知识点阐述  

## bin log

1. 作用

   **binlog(归档日志) 是逻辑日志**, 存储的是每一条SQL 

   逻辑的意思是，迁移到其他MySQL实例上也行，即使其他的是MyISAM。

   主要作用:**备份恢复and主从复制**

2. 格式

   3种格式， 一般推荐使用row格式

   - row : 基于行的模式，记录的是行的变化，很安全
   - statement : 基于SQL语句的模式，某些语句中含有一些函数，例如 UUID NOW 等在复制过程可能导致数据不一致甚至出错
   - mixed : 混合模式，根据语句来选用是 statement 还是 row 模式

3. 关联

   redo log 和 binlog 有一个共同的数据字段叫 **XID**。崩溃恢复的时候会按顺序扫描 redo log。<br/>如果碰到既有 prepare、又有 commit 的 redo log就直接提交<br/>如果碰到只有 parepare、而没有 commit 的 redo log就拿着 XID 去 binlog 找对应的事务。

## redo log

1. 作用

    **redo log通常是物理日志**，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样。它用来**在崩溃后恢复<br>

    - 1、**增加服务的吞吐**，因为写日志是增量追加，很快啊 <br>
    - 2、**高可用**，即使服务重启、死掉，也可以从redo log 恢复，称为 **crash-safe**
      - 注意:**redo log 是InnoDb引擎引入的，Server层并没有redo log**，即MyISAM引擎并没有**crash-safe**能力<br>
      - 恢复是恢复到commit后的物理数据页**(恢复数据页，且只能恢复到最后一次提交的位置)

2. 格式

    - MySQL redo log，默认配置下有两个文件，分别是ib_logfile0和ib_logfile1，这两个文件有完全相同的格式

    - redo log 文件最小单位是512字节的一个块，每个块的最后4个字节，存储这个块的checksum校验值

    - redo log 文件前4个块，也就是前2048个字节为文件头，文件头存储了redo log文件元数据信息和checkpoint信息

    - 整体来看redo log文件格式如下：

      ```mysql
         0 --------------------------------
                  log file header block
      512 ---------------------------------
                  checkpoint block1
      1024--------------------------------
                  5.7保留，8.0用于加密
      1536--------------------------------
                  checkpoint block2
      2048--------------------------------
                  redo log record ...
      xxxxx--------------------------------
      ```

      参考文档[MySQL redo log 格式解析](http://www.weijingbiji.com/2183/)

3. 写入过程

   写redo log的方式，是WAL技术，即Write-Ahead Logging, 核心就是:**先写日志，再更新磁盘文件**

   因为磁盘文件更新很慢，要定位、磁盘寻址、修改，所以就先记在redo log上，有空的时候再更新。

   所以， MySQL定义的insert\update语句执行完成就是: **先写入redo log, 再更新内存，就算完成**(刷新磁盘的事不着急，慢慢刷)

   

   其实redo log的写入过程就是**2阶段提交(2PC)**.

   - 执行器调用引擎写入数据，写到了redo log
   - redo log写入后，处于prepare状态 
   - 执行器生成binlog,并写入磁盘 
   - 执行器调用引擎接口提交，引擎将redo log的状态流转，从prepare -> commit

   ![img](https://www.linuxidc.com/upload/2018_11/181121105137361.jpg)

   > 图片来自极客时间，该图展示了一组4个文件的redo log日志，checkpoint之前表示擦除完了的，即可以进行写的，擦除之前会更新到磁盘中，write pos是指写的位置，当write pos和checkpoint相遇的时候表明redo log已经满了，这个时候数据库停止进行数据库更新语句的执行，转而进行redo log日志同步到磁盘中。

4. redo log 写入过程中如果宕机了，怎么办？

   1. prepare阶段 

   2. 写binlog 

   3. commit

   **当在2之前崩溃时**,重启恢复：发现没有commit，回滚。

   备份恢复：没有binlog 。和崩溃前一致

   **当在3之前崩溃**重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit.

   备份恢复：有binlog. 一致

## undo log

1. undo log的作用

   **undo log一般是逻辑日志，根据每行记录进行记录**<br>用来在**事务**中回滚行记录到某个版本。

2. undolog和redo log的关系

   **undo log**也会产生redo log

3. 多版本控制

   InnoDB的多版本使用undo来构建， 这很好理解，undo log 中包含了记录更改前的镜像，

   如果更改数据的事务未提交，对于隔离级别大于等于read commit的事务而言，它不应该看到已修改的数据，而是应该给它返回老版本的数据。

