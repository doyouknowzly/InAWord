| 序号 | 问题                     | 一句话解释                                                   |
| ---- | ------------------------ | ------------------------------------------------------------ |
| 0    | MySQL的架构分层          | 客户端;<br>连接器、缓存层、分析器、优化器、执行器;<br>存储引擎层 |
| 1    | MySQL的文件存储          | .idb文件中存储索引和行数据<br>**段**、1MB的**区**、16KB的**页**<br>InnoDB不是按行的来操作的，它可操作的最小粒度是页，<br>页加载进内存后才会通过扫描页来获取行/记录。 |
| 2    | MySQL数据页的写入流程    |                                                              |
| 3    | 页分裂是什么？页合并呢？ | 页分裂：即将满的页内，又插如了一条数据 (min < x < max), 因为放不下，只能新增一页，移动后面的数据到新页 |



### 0. MySQL的架构分层

- 1.客户端，我们自己的服务
- 2.连接器，包括授权认证、连接处理等；
- 3.缓存层，如果命中内存就直接返回了，不用查文件系统. 但查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。<br>**注意:MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了** 
- 4.分析器，有点像编译器的分词器，进行词法分析、语法分析
- 5.优化器，执行计划的生成，选择合适的索引等 
- 6.执行器，操作API，返回结果
- 7.存储引擎层，去实现MySQL的Api, 但不解析Sql。比如InnoDb和MyISAM其中，除了引擎层，其他的都属于Server层  



### 1. MySQL的文件存储

- 文件路径

  假设你已经装好了MySQL最新的5.7版本，并且你创建了一个`windmills`库（schema）和`wmills`表。在文件目录（通常是`/var/lib/mysql/`）你会看到以下内容：

    ```mysql
    data/
      windmills/
          wmills.ibd
          wmills.frm
    ```

    这是因为从MySQL 5.6版本开始`innodb_file_per_table`参数默认设置为1。该配置下你的每一个表都会单独作为一个文件存储（如果有分区也可能有多个文件）

    目录下要注意的是这个叫`wmills.ibd`的文件, 这个文件就是innodb引擎下的索引文件(.idb), 又因为innodb使用聚簇索引的方式， 数据和索引文件放在一起，即.idb文件

- .idb的文件结构

  1. 文件由多个**段**（segments）组成，每个段和一个索引相关。

  2. 比段更小的结构是**区**，区仅存在于段内，并且每个区都是固定的1MB大小（页体积默认的情况下）

  3. **页**则是区的下一级构成单位，默认体积为16KB。

     - 一个区可以容纳最多64个页
     - 一个页可以容纳2-N个行 (行的数量取决于它的大小，由你的表结构定义)
     - InnoDB要求页至少要有两个行， 所以行的大小最多为8000 byte

     页的结构图: 

  ![img](https://pic3.zhimg.com/80/v2-3f061ac8f9efb6e1652f094a5983ddaa_720w.jpg)

  > 页可以空或者填充满（100%），行记录会按照主键顺序来排列。例如在使用`AUTO_INCREMENT`时，你会有顺序的ID 1、2、3、4等。

### 2. MySQL数据页的写入流程

> 参考文档[InnoDB中的页合并与分裂](https://zhuanlan.zhihu.com/p/98818611)

页有一个重要的属性：`MERGE_THRESHOLD`。该参数的默认值是50%页的大小，它在InnoDB的合并操作中扮演了很重要的角色。

![img](https://pic2.zhimg.com/80/v2-6daba443c0b19c9956612fc3816dbd01_720w.jpg)

当你插入数据时，如果数据（大小）能够放的进页中的话，那他们是按顺序将页填满的。

若当前页满，则下一行记录会被插入下一页（NEXT）中。

![img](https://pic3.zhimg.com/80/v2-f3497d7e821abdfd51797a80bf0e68c2_720w.jpg)

### 3. 页分裂是什么？页合并呢？

> 页分裂会发生在插入或更新操作时，并且造成页的错位（dislocation，落入不同的区）

> 在合并和分裂的过程，InnoDB会在索引树上加写锁（x-latch）。在操作频繁的系统中这可能会是个隐患。它可能会导致索引的锁争用（index latch contention）

#### 页合并

当你删了一行记录时，实际上记录并没有被物理删除，记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。

![img](https://pic1.zhimg.com/80/v2-6a9fd05c70648eabfb153f9c38b081d4_720w.jpg)

当页中删除的记录达到`MERGE_THRESHOLD`（默认页体积的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。

![img](https://pic3.zhimg.com/80/v2-f3497d7e821abdfd51797a80bf0e68c2_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-ed174fc87f4037da0ed81cd1268653b5_720w.jpg)

合并操作使得页#5保留它之前的数据，并且容纳来自页#6的数据。页#6变成一个空页，可以接纳新数据。

![img](https://pic3.zhimg.com/80/v2-345d5647e15879a7342895d07fe1906e_720w.jpg)



**页分裂**

前面提到，页可能填充至100%，在页填满了之后，下一页会继续接管新的记录。但如果有下面这种情况呢？

![img](https://pic3.zhimg.com/80/v2-750b0a4f535435653c13cdcb0c853d06_720w.jpg)

页#10没有足够空间去容纳新（或更新）的记录。根据“下一页”的逻辑，记录应该由页#11负责。然而：

![img](https://pic1.zhimg.com/80/v2-575acc29a4e0312db70a515ab71d6d90_720w.jpg)

页#11也同样满了，数据也不可能不按顺序地插入。怎么办？



InnoDB的做法是（简化版）：

1. 创建新页
2. 判断当前页（页#10）可以从哪里进行分裂（记录行层面）
3. 移动记录行
4. 重新定义页之间的关系

![img](https://pic3.zhimg.com/80/v2-eb81b65c29711b609e2076af48c17146_720w.jpg)



这样B+树**水平方向的一致性仍然满足**，因为满足原定的顺序排列逻辑。

然而从**物理存储上讲页是乱序的**，而且大概率会落到不同的区。

这样在加载索引文件到内存的时候就会比较慢，因为不连续。MySQL自然很想解决这种乱序的问题，思路如下:

1. 新分裂的页因为数量比较少，被合并了

2. 使用`OPTIMIZE`重新整理表,  涉及很复杂的文件读写、复制和移动

   这可能是个很重量级和耗时的过程，但可能是唯一将大量分布在不同区的页理顺的方法。