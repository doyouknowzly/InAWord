# 索引

## 引言

概括来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样，存储了内容 -->位置的映射，方便迅速定位。

一般来说，实现索引的思路有3种 :

 - **哈希表**

   优点: 读、写性能高， 时间复杂度是 O(1)。 

   缺点: 只适用于等值查询，即"=", 比如Memcached等NoSQL

 - **有序数组**

   优点: 等值和范围查询的性能都很好， 时间复杂度是 O(log(N))。 

   缺点: 写入、删除的成本太高，后面的节点全要移动；所以只适用于数据很少变化的场景，比如你要保存的是 2021年深圳出生的婴儿信息

 - **搜索树**

   针对上面的2种数据结构，进行折中的一种结构，也是数据库索引使用的比较普遍的结构。

   常见的搜索树有: 二叉搜索树、B-树(B树)、B+树、AVL树等



索引的实现是在存储引擎层，即InnoDB 和 MyISAM等引擎的索引结构是不一样的

## 常见问题

| 序号 | 问题                                                         | 一句话解释                                                   | 详细知识点                                                   |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 0    | B+ 树为什么被MySQL采用作为索引的数据结构？                   | <br>优点：IO读取次数少（每次都是页读取），<br>范围查找更快捷（相邻页之间有指针） | [深入理解 MySQL 索引底层原理](https://zhuanlan.zhihu.com/p/113917726) |
| 1    | B+树和其他树的对比                                           |                                                              |                                                              |
| 2    | MySQL都有哪些索引？使用场景都是哪些？                        | 主键索引<br>辅助索引<br>聚簇索引<br>非聚簇索引<br>全文索引<br>唯一索引<br>主键索引<br>组合索引<br> |                                                              |
| 3    | 聚簇索引（也叫聚集索引， cluster index） 是什么？<br>为什么比普通索引快？ | 数据和索引放在一起，放在B+树的叶子节点上，不需要根据地址再去查一下具体数据是多少 |                                                              |
| 4    | InnoDB的B+树索引叶子节点的Data域存储的是什么？MyISAM的呢？   | MyISAM 引擎把数据和索引分开了，一人一个文件，这叫做非聚集索引方式<br>(.MYD文件:表里面的数据文件（myisam data）<br>.MYI文件:表里面的索引文件（myisam index）)；<br><br>树的叶子节点存的是对应数据的物理地址。我们拿到这个物理地址后，就可以到 MyISAM 数据文件中直接定位到具体的数据记录了<br><br>Innodb引擎把数据和索引放在同一个文件里了，这叫做聚集索引方式(.idb文件:表里面的数据+索引文件) <br> InnoDB 只在主键索引树内使用聚簇索引，因为其他索引也存数据的话，太浪费空间了 <br> | [深入理解 MySQL 索引底层原理](https://zhuanlan.zhihu.com/p/113917726) |
| 5    | MySQL索引什么时候会失效                                      | 一、使用联合索引a,b时，未使用最左前缀规则<br>二、使用like的时候没有使用左前缀，比如where subject like "%game"<br>三、搜索一个索引而在另一个索引上做order by，where A=a order by B <br>四、where A = a1 or B = b1会失效,因为是2个索引,<br>where A = a1 or A = a2时生效<br>五、varchar类型的时候如果没加"",就会做类型转换，然后索引失效 | [MySQL索引——分类、何时使用、何时不使用、何时失效](https://blog.csdn.net/weixin_39420024/article/details/80040549) |
| 6    | 索引覆盖是什么意思？回表呢？                                 | 索引覆盖 : select的字段，和where条件的字段，全在同1个非聚簇索引上<br>回表 : 根据2级索引再查一次聚簇索引 | [到底什么情况下MySQL innodb会发生回表操作?](https://www.zhihu.com/question/347087093/answer/830934717) |
| 7    | 为什么二级索引的叶子节点要存主键，而不是直接存物理地址呢     |                                                              |                                                              |





## 详细知识点阐述  

### 0. **B+ 树为什么被MySQL采用作为索引的数据结构？** 

**核心思路**:   

   - 索引文件很大，是存在磁盘中的，一次只能读取几页的索引到内存中，所以要尽量**减少IO读取次数**  ；
   - 即增加N叉树的N值，N越大，层数就越少，刷磁盘页的次数平均就比较少，性能就好
   - N的大小又和页大小成反比， 即每页越大，N就越小
   - 假设N=1200，当层高为4时，子节点个数就 = (1200)^3， 约等于17亿了，能存下大部分数据了。

**优点 ** : 

   - 1.  数据都在叶子节点，查询效率稳定

   - 2. 相近的节点在叶子节点的逻辑上邻近的，在索引文件的物理存储中也是相近的，可以1次都加载进来，可能不需要多次读磁盘\刷内存的操作 

   - 3. 存在叶子节点间的链表指针，方便select \*进行扫库，从任意一个节点都可以遍历完全表   





### 1. **B+树和其他树的对比**

- **二叉查找树(binary Search)**：左子树的键值小于根的键值，右子树的键值大于根的键值； 缺点:不平衡的时候，其实和链表是一样的，效率很低<br> 
- **平衡二叉树(AVL Tree)**  add和remove的时候会自动旋转，用来保持平衡，即根节点两边的子节点数量尽量一致<br>  
- **平衡多路查找树(B-tree，-是分割，不是减)** 所有键值分布在整个树中；叶子节点不需要非是2;<br>关键字越少，层数越高，IO次数越多，所以有要求【m叉查找树内，除了根结点外，任何结点至少有 m/2 个分叉，即至少含有m/2 -1个关键字】 <br> 
- **B+树** 叶子节点不需要非是2个;不需要经常平衡; 数据全部在叶子节点上；叶子节点间加入链表指针，优化where等范围查找时的性能<br> B+树的创造者，Rudolf Bayer没有解释B代表什么，最常见的观点是B代表平衡(balanced)

> 参考文档 [<<那么多的树，一文全总结>>](> https://segmentfault.com/a/1190000038444596?utm_source=tag-newest)



### 6. 索引覆盖是什么意思？回表呢？

**索引覆盖**: 只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。例如：select id,age from user where age = 10;

一般是指， select的字段，和where条件的字段，全在同1个非聚簇索引index上



**回表**: 根据二级索引查到主键后，再去主键索引文件中查数据行





