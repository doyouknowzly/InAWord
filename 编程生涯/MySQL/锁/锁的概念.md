# MySQL 的锁
## 一、共享锁vs排他锁

1. 释放条件: 

	- 锁只有在执行commit或者rollback的时候才会释放, 并且所有的锁都是在**同一时刻**被释放。

2. 共享锁：

	- 别名 【读锁】、【s锁】(Shared)
	- 其他事务可以读，但不能写， 即【读读可以并行】
	- 加锁的条件:

		- 任何select语句
		- 显式声明 select *** in share mode (等价于隐式select)

3. 排他锁 ：

	- 别名【写锁】、【x锁】(Exclusive)
	- 其他事务不能读取，也不能写，即【写读，写写不可以并行】
	- 加锁的条件: 
		- 对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB会自动给涉及数据集加排他锁（X)
		- 显式声明  : SELECT *** FOR UPDATE （此时select 就等同一个update语句）


## 二、行锁vs表锁
### 行锁
1. 实现方式: 

- Record Lock : 单个行记录上加锁 (**本质就是锁住当前的索引节点**， 如果没有索引，就隐式使用主键索引)
    - 使用辅助索引查询时，辅助索引和对应id的主键索引**都会**加锁
- Gap Lock: 间隙锁，锁定一个范围，但不包括某条记录本身
- Next-Key Lock: 上两个锁的和， 既包括范围，又包括记录自己 (包含的范围 : 当前索引-->下一个值之间的范围)

   

2. 当查询的索引含有**唯一**属性时，InnoDB引擎会优化，将**Next-Key**降级为**Record** (因为就一条，没必要搞范围锁)

3. 同一条SQL， 不同索引文件之间，**锁住的行是一致的**，但可能用的索引方式不一样 (比如主键索引用record, 辅助索引用next-key)

   - 注意： 只会锁住主键索引 和 某一个辅助索引， 假设表由4个单独的辅助索引（而不是联合索引），where条件里也都带了，也只会由MySQL优化器选择1个索引， 又因为会**回表**,  才会又锁住主键索引

4. **特别需要注意的是**:  除了当前索引值外，InnoDB引擎还会对**索引**的**下一个**键值**之前**加上gap lock，形成next-key lock

   目的 : 为了防止幻读(Phantom)问题 

   > 幻读: 连续两次的select 结果不一样， 违反了事务的隔离性原则

   处理思路： 

   - 假设数据库中有， 1，10两条记录，
   - select * from  table where id > 5,  可以查出来10这一条记录
   - 假设不使用next -key,  而只对索引=5的record单行加锁
   - 如果有事务新增了 id = 7 (锁只在id=5, 所以可以正常写入)
   - 下次select * from  table where id > 5， 就会查出7,10两天记录
   - 所以要锁**一个范围**

### 表锁
只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！  
MyISam只能使用表锁

## 三、意向锁

> 意向锁本身并没有锁住数据，意向锁是在添加行锁之前添加。

意向锁只是为了方便事务加表锁的，提高效率的一个手段， 相当于是一个boolean existRecordLock = true



**加表锁前，肯定要保证该表所有记录都没有行锁，对吧**

1. 如果没有意向锁，就需要遍历记录，挨个看有没有加行锁，效率很低。
2. 而查看 existRecordLock 是否是true，就是很快的操作



参考文档： https://www.zhihu.com/question/51513268

innodb何时会加表锁: 如果没有正确使用 索引，导致全表扫描的时候



**IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突**
