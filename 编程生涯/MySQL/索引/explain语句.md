> 参考文章: https://zhuanlan.zhihu.com/p/341595489

只需要在SQL语句前加上explain关键字就可以查看执行计划，执行计划包括以下信息：

id、select_type、table、partitions、type、possible_keys、key、key_len、ref、rows、filtered、Extra，总共12个字段信息



![img](https://pic4.zhimg.com/80/v2-daa257587fadcd8bee9e4a9b6cef6527_720w.jpg)

| 序号 | 字段名        | 作用                                                         | 可能的值                                                     |
| ---- | ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | id            | 标识select查询的id, 复合查询时会用到(多个select)<br>当id不同时，SQL从大到小执行，id相同则从上到下执行 |                                                              |
| 2    | select_type   | select查询的类型                                             |                                                              |
| 3    | table         | 表示输出结果集的表的表名，并不一定是真实存在的表，也有可能是别名，临时表等等 |                                                              |
| 4    | partitions    | 表示SQL语句查询时匹配到的分区信息，对于非分区表值为NULL，当查询的是分区表则会显示分区表命中的分区情况 |                                                              |
| 5    | **type**      | 需要重点关注的一个字段信息，表示查询使用了哪种类型，在 `SQL`优化中是一个非常重要的指标 | 依次从优到差分别是：<br>**system > const > eq_ref > ref > range > index > ALL** |
| 6    | possible_keys | 表示在查询中可能使用到的索引来查找，别列出的索引并不一定是最终查询数据所用到的索引。<br>**系统估计可能用的几个索引,但最终,只能用1个.** |                                                              |
| 7    | key           | 跟possible_keys有所区别，key表示查询中实际使用到的索引，若没有使用到索引则显示为NULL。 | primary, 字段名， null                                       |
| 8    | key_len       | 表示查询用到的索引key的长度(字节数)。如果单列索引，那么就会把整个索引长度计算进去，如果是联合索引，不是所有的列都用到，那么就只计算实际用到的列，因此可以**根据key_len来判断联合索引是否生效**。 |                                                              |
| 9    | ref           | 显示了哪些列或常量被用于查找索引列上的值                     | `const`，`func`，`null`，字段名                              |
| 10   | rows          | mysql**估算**要找到我们所需的记录，需要读取的行数。可以通过这个数据很直观的显示 `SQL` 性能的好坏，一般情况下 `rows` 值越小越好 |                                                              |
| 11   | filtered      | 指返回结果的行占需要读到的行(rows列的值)的百分比，一般来说越大越好 |                                                              |
| 12   | **Extra**     | 表示额外的信息。此字段能够给出让我们深入理解执行计划进一步的细节信息 |                                                              |



## 2.select_type



- **SIMPLE**

  表示最简单的查询操作，也就是查询SQL语句中没有子查询、union等操作。

- **PRIMARY**

  当查询语句中包含复杂查询的子部分，表示复杂查询中最外层的 select。

- **SUBQUERY**

  当 `select` 或 `where` 中包含有子查询，该子查询被标记为SUBQUERY。

- **DERIVED**

  在SQL语句中包含在`from`子句中的子查询。

- **UNION**

  表示在union中的第二个和随后的select语句。

- **UNION RESULT**

  代表从`union`的临时表中读取数据。



## 5.type

- **system和const**

  **单表中最多有一条匹配行，查询效率最高，所以这个匹配行的其他列的值可以被优化器在当前查询中当作常量来处理**。

  通常出现在根据主键或者唯一索引进行的查询，system是const的特例，表里只有一条元组匹配时（系统表）为system。

- **eq_ref**

  primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录，所以这种类型常出现在多表的join查询。

- **ref**

  相比**eq_ref**，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，可能会找到多个符合条件的行。

- **range**

  使用索引选择行，仅检索给定范围内的行。一般来说是针对一个有索引的字段，给定范围检索数据，通常出现在where语句中使用 `bettween...and`、`<`、`>`、`<=`、`in` 等条件查询 。

- **index**

  扫描全表索引，通常比ALL要快一些。

- **ALL**

  **全表扫描，MySQL遍历全表来找到匹配行**，性能最差。



## 12. Extra

表示额外的信息。此字段能够给出让我们深入理解执行计划进一步的细节信息。

### **Using index**

说明在select查询中使用了覆盖索引。覆盖索引的好处是一条SQL通过索引就可以返回我们需要的数据。

### **Using where**

查询时没使用到索引，然后通过where条件过滤获取到所需的数据。

### **Using temporary**

表示在查询时，MySQL需要创建一个临时表来保存结果。临时表一般会比较影响性能，应该尽量避免。

有时候使用DISTINCT去重时也会产生Using temporary。

### **Using filesort**

我们知道索引除了查询中能起作用外，排序也是能起到作用的，所以当SQL中包含 ORDER BY 操作，而且**无法利用索引完成排序操作**的时候，MySQL不得不选择相应的排序算法来实现，这时就会出现**Using filesort**，应该尽量避免使用**Using filesort**。