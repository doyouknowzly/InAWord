
# 事务

[toc]

**MySQL默认采用自动提交(autocommit)模式。这就表示除非显式地开始一个事务，否则每个查询都被当做一个单独的事务自动执行**

## 0. 事务的4大特性
1. 隔离性----->锁 & MVCC
2. 原子性----->undo log
3. 持久性----->redo log
4. 一致性 是结果

## 1.事务的隔离级别

### 1.1 须知，**隔离级别越高，性能就越差** 

所以我们大多数时候是在性能和数据一致性之间找一个平衡，根据业务的要求而定。

下面的隔离级别，从上往下**越来越严，性能越来越差**

1. 读未提交（read uncommitted）

   一个事务可以读到另一个未提交事务修改过的数据

   原理 : 直接返回，不额外处理

2. 读提交（read committed）

   一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值

   原理 : **ReadView**，每个SQL执行的时候创建的视图

3. 可重复读（repeatable read）

   在一些业务场景中，一个事务只能读到另一个已经提交的事务修改过的数据，但是第一次读过某条记录后，即使其他事务修改了该记录的值并且提交，该事务之后再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据

   原理 : **ReadView**， 事务启动时创建的**唯一的**一个视图

4. 串行化（serializable ）

   以上3种隔离级别都允许对同一条记录进行`读-读`、`读-写`、`写-读`的并发操作，如果我们不允许`读-写`、`写-读`的并发操作，可以使用`SERIALIZABLE`隔离级别

   原理 : 读写锁，后来的线程需要等待



### 1.2 不同事务级别会导致的问题

(x代表不会出现，Y代表会)

| 隔离级别                     | 第一类丢失更新 | 第二类丢失更新 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | -------------- | -------------- | ---- | ---------- | ---- |
| SERIALIZABLE （串行化）      | X              | X              | X    | X          | X    |
| REPEATABLE READ（可重复读）  | X              | Y              | X    | X          | Y    |
| READ COMMITTED （读已提交）  | X              | Y              | X    | Y          | Y    |
| READ UNCOMMITTED（读未提交） | X              | Y              | Y    | Y          | Y    |

参考 [锁的分类](../锁/锁的分类)

> InnoDB牛逼！ 使用next-key锁，在可重复读的级别下，达到了串行化的隔离要求，避免了幻读问题



### 1.3 并发事务会导致的问题详解

1. 第一类丢失更新
   - 定义：A事务撤销时，把已经提交的B事务的更新数据覆盖了。
   - 解决方式 : 使用排他X锁
2. 第二类丢失更新
   - 定义：A事务提交时，把已经提交的B事务的更新数据覆盖了。
   - 解决方式 : 使用排他X锁 
     - select语句附带 select *** for update
   
   > 丢失更新，几乎所有的数据库，所有的隔离级别，都能避免丢失更新的情况出现。
   >
   > 但， 业务上的丢失更新很难避免， 比如两个进程，各自读到了自己的内存，过一段时间后update，
   >
   > 就会出现 这种 **"业务上的丢失更新"**
3. 脏读
   - 定义：读到未commit的数据
4. 不可重复读
   - 定义：不会读到未commit的数据，但一个事务范围内两个相同的查询却返回了不同数据。(还是被其他事务的commit的数据影响了)
5. 幻读
   - 范围读时，读到已commit的**插入**数据。



> 幻读vs不可重复读， 区别主要是  **范围查询vs等值查询**, **insert 和 update**

- 不可重复读是 ， where age = 10， 第一次是 张三, 第二次是李四
- 幻读是， where age < 10, 第一次有2条记录，第二次有3条记录，且新增的这条是其他事务commit的



## 2. 事务的隔离级别原理

### 2.1 串行化

> 因为InnoDB在REPEATABLE READ（可重复读）的情况下就能避免幻读，所以本地事务基本不用串行化的级别，一般是分布式事务使用

串行化的情况下，InnoDB引擎会给每个select 语句自动加上 lock in share mode, 即为每个读操作加一个共享锁 (s锁)。

### 2.2 可重复读

可重读读和已提交读，都使用**MVCC**来实现

### 2.3 已提交读

和可重复读的区别在于，生成ReadView的时机不同

- REPEATABLE READ 

  在第一次读取数据时生成一个ReadView

  ![图片](https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpxIiaicKYEDP7EgUawL2URB6alLIicqMMJic9z7q9Yb9SsVya7GMuyV4D78L170xdcIuWM0sIMKlMhicLA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

- READ COMMITTD

  在每一次进行普通SELECT操作前都会生成一个ReadView
  
  ![图片](https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpxIiaicKYEDP7EgUawL2URB6aptNsaNBzEhLY8t3mQZWkPDCuHib9703wQAQLay1fa8wnx7gZ73LVxwQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 2.4 未提交读

对于使用`READ UNCOMMITTED`隔离级别的事务来说，直接读取记录的最新版本就好了，什么额外的操作都不用做







## 3.MySQL如何实现事务的？



ACID参见 [事务基础](../../../../微服务/事务/事务基础)

1. 原子性（**A**tomicity）

   **如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行回滚**

   MySQL通过**回滚日志（undo log）** 实现回滚操作

   > 所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 **回滚日志** 中的信息将数据回滚到修改之前的样子即可

   **undo会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚之前未完成的事务。**

2. 隔离性（**I**solation）

   通过 行锁next-key lock实现, 参考 [锁的分类](../锁/锁的分类)

3. 持久性（**D**urability）

   **要实现持久性，就是要在事务提交时，就保证一定落到磁盘了**

   MySQL是通过InnoDb引擎的redo log来 实现持久性的， 当事务提交的时候，会将`redo log`日志进行刷盘

   > redo log频繁刷盘会不会影响性能？ 参考[redoLog](../log/redoLog)

4. 一致性（**C**onsistency）

   一致性是结果，通过保证AID来保证C


