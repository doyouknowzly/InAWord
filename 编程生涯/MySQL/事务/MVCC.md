# MVCC

参考文档

https://zhuanlan.zhihu.com/p/166152616

https://mp.weixin.qq.com/s/0-YEqTMd0OaIhW99WqavgQ

## 1.MVCC是什么

MVCC(Multi-Version Concurrency Control)即多版本并发控制, **只适用于Msyql隔离级别中的读已提交(Read committed)和可重复读(Repeatable Read)**。

> Read uncommitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC

**MVCC**使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能。



## 2 原理

MySQL的行记录，除了存储用户定义的列之外，还有2-3个额外的隐藏列 

- 如果没有显式指定主键，会有row_id
- 6字节的事务ID
- 7字节的回滚指针 (undo log)

每次对记录进行改动，都会记录一条`undo日志`，每条`undo日志`也都有一个`roll_pointer`属性（`INSERT`操作对应的`undo日志`没有该属性，因为该记录并没有更早的版本），可以将这些`undo日志`都连起来，串成一个链表，所以现在的情况就像下图一样：

![img](https://pic4.zhimg.com/80/v2-f9752c60130ab2185341299162670c4b_720w.jpg)

还有一个核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。

所以设计`InnoDB`的大叔提出了一个`ReadView`的概念，这个`ReadView`中主要包含当前系统中还有**哪些活跃的读写事务**，把它们的事务id放到一个列表中，我们把这个列表命名为为`m_ids`。这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

1. 如果被访问版本的`trx_id`属性值（隐藏的列，意思是事务ID）小于`m_ids`列表中最小的事务id，表明生成该版本的事务在生成`ReadView`前已经提交，所以该版本可以被当前事务访问。
2. 如果被访问版本的`trx_id`属性值大于`m_ids`列表中最大的事务id，表明生成该版本的事务在生成`ReadView`后才生成，所以该版本不可以被当前事务访问。
3. 如果被访问版本的`trx_id`属性值在`m_ids`列表中最大的事务id和最小事务id之间，那就需要判断一下`trx_id`属性值是不是在`m_ids`列表中，如果在，说明创建`ReadView`时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建`ReadView`时生成该版本的事务已经被提交，该版本可以被访问。



如果某个版本的数据对当前事务不可见的话，那就 **顺着版本链找到下一个版本的数据**，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本，如果最后一个版本也不可见的话，那么就意味着该条记录对该事务不可见，查询结果就不包含该记录。

### 2.3 优缺点

MVCC在大多数情况下代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。

缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作。