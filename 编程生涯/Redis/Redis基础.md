# Redis
Remote Dictionary Service 远程字典服务

[toc]



## 一、Redis到底是不是单线程

> 参考文章 [《Redis 6.0 多线程IO处理过程详解》](https://zhuanlan.zhihu.com/p/144805500)

的确是单线程，因为Redis大部分操作都不需要大量计算，CPU不是瓶颈。相反，往往网络IO和内存大小才是瓶颈。

所以使用NIO

- 基于Reactor模型，1个网络IO线程同时监听多个TCP套接字,扔到一个队列中缓存起来，进行I/O多路复用
- 1个读写线程用以响应队列中的事件

但除了IO线程、读写线程外，还有后台线程，做一些边角料工作(AOF、对象释放)



Redis 6.0， 使用Master-Worker模型，1个Master线程用来处理数据的写入；

多个worker线程用来进行Socket连接，处理缓存区、等待响应等逻辑，数据读写交回Master线程处理

## 二、Redis为什么高性能



**首先，采用了多路复用io阻塞机制**
**然后，数据结构简单，操作节省时间**
**最后，运行在内存中，自然速度快**



## 三、缓存穿透vs缓存雪崩

### 缓存穿透

一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

如何避免？

1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。

2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。



### 缓存雪崩

当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。

如何避免？

1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期

3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。



## 四.redis实现分布式锁

参考文章  [Redlock安全吗？](http://antirez.com/news/101)

分布式锁的要求 : 互斥性、安全性、避免死锁、高可用。

基于`redis`(要通过Lua脚本，因为setnx命令不能原子地设置过期时间。

又因为redis集器要考虑更复的场景，所以Redis作者antirez给出了RedLock算法解决,但本质上也不能完全可信)







