# Redis持久化



| 序号 | 问题             | 一句话总结                                                   | 参考文档 |
| ---- | ---------------- | ------------------------------------------------------------ | -------- |
| 0    | 持久化方式的选择 | Redis如果开启了AOF和RDB，会优先使用AOF，因为性能更好<br>     |          |
| 1    | AOF重写原理      | 时间久了以后，AOF文件很大，而且很多都是用不到的，比如[set a 123; set a 456; set a 789],其实最终只需要789就行了<br>**原理** : 没有使用分析、合并命令的思路，而是类似RDB一样，分析当前集群的数据状态，生成的命令集合。<br>会新启动一个进程异步进行AOF重写，此时还会多一个**AOF重写缓冲区**，主进程的命令在执行完后，还会同时将命令追加打AOF缓冲区和AOF重写缓冲区 |          |
| 2    | 混合持久化       |                                                              |          |



## RDB

**RDB是快照方式**，周期性地持久化内存的快照, 单纯地copy快照地二进制数据到磁盘里。

**SAVE命令**会阻塞主进程，直到生成完RDB文件后才响应客户端;一般不使用 

**BGSAVE命令**会派生出一个子进程写RDB文件

- 缺点: 
  - 更耗时、更密集地消耗资源; 
  - 不会时刻都进行持久化，可能会丢失分钟级别地数据 (根据配置地持久化周期而定)
- 优点: 同样地数据，空间占用更小





## AOF

**AOF**是增量地，append only地记录每条操作的指令，就很像mysql的binlog.

- **优点 **: AOF是1秒1次的，最多丢失1秒的数据，数据一致性更强。

- **缺点 **: 同样的数据，AOF文件更大更占空间

  

命令先写到**AOF内存缓冲区**内，定时刷到磁盘中。（因为如果每时每刻都刷磁盘是很慢的）

- 默认每秒都要去异步刷新一次日志，进行**fsync**。



## 二、混合持久化

重启Redis服务时，一般运维都不会使用RDB恢复，因为丢失的数据可能有好几分钟。

但是如果全部使用AOF恢复也不行，太慢了，因为要一条一条指令Redo



所以Redis 4.0以后开启了 **混合持久化**的方案，RDB每次持久化都标记为一个记录点，每次AOF要存储的都是**最新一个记录点到当前的数据**

这样，AOF要存储的数据量就很小，也不会丢失太多数据，理论上和纯AOF是一样的。



恢复的时候，先恢复RDB到最新的记录点，再恢复剩余的AOF日志，效率和速度也会高很多
