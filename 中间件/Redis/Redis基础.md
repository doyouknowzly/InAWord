# Redis
Remote Dictionary Service 远程字典服务

[toc]



## 一、Redis到底是不是单线程

> 参考文章 [《Redis 6.0 多线程IO处理过程详解》](https://zhuanlan.zhihu.com/p/144805500)

的确是单线程，因为Redis大部分操作都不需要大量计算，CPU不是瓶颈。相反，往往网络IO和内存大小才是瓶颈。

所以使用NIO

- 基于Reactor模型，1个网络IO线程同时监听多个TCP套接字,扔到一个队列中缓存起来，进行I/O多路复用
- 1个读写线程用以响应队列中的事件

但除了IO线程、读写线程外，还有后台线程，做一些边角料工作(AOF、对象释放)



Redis 6.0， 使用Master-Worker模型，1个Master线程用来处理数据的写入；

多个worker线程用来进行Socket连接，处理缓存区、等待响应等逻辑，数据读写交回Master线程处理

## 二、Redis为什么高性能



## 三、缓存穿透vs缓存雪崩



## 四、Redis事务









| 序号 | 问题                                          | 一句话总结                                                   | 参考文档 |
| ---- | --------------------------------------------- | ------------------------------------------------------------ | -------- |
| 2    | 如何实现分布式锁？                            |                                                              |          |
| 4    | 过期策略                                      | 定期删除+惰性删除+内存淘汰策略<br>redis默认每个隔100ms随机抽查一部分key;<br>因为是抽查，所以部分key过期但一直没被抽到，所以需要惰性删除<br>内存淘汰策略是兜底策略，在redis.conf中配置LRU、random等策略 |          |
| 5    | Redis事务                                     |                                                              |          |
| 6    | 缓存穿透vs 缓存雪崩                           | 缓存穿透：用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，数据库也找不到;<br>缓存雪崩：在同一时刻出现大面积的缓存过期<br><br>解决方案:分布式锁、范围内随机过期时间、缓存预热、布隆过滤器等 |          |
| 7    | Redis为什么高性能？                           | (一)纯内存操作<br>(二)单线程操作，避免了频繁的上下文切换<br>(三)采用了非阻塞I/O多路复用机制 |          |
| 9    | 3种缓存读写策略(旁路缓存、读写穿透、异步写入) |                                                              |          |
| 10   | Node间的命令                                  | Meet, <br>Ping[每个Node每秒去像本地缓存的集群其他节点进行Ping,确保其他人的存活], <br>Pong, <br>Fail, <br>Publish |          |

