# Redis
Remote Dictionary Service 远程字典服务

[toc]



## 一、Redis到底是不是单线程

> 参考文章 [《Redis 6.0 多线程IO处理过程详解》](https://zhuanlan.zhihu.com/p/144805500)

的确是单线程，因为Redis大部分操作都不需要大量计算，CPU不是瓶颈。相反，往往网络IO和内存大小才是瓶颈。

所以使用NIO

- 基于Reactor模型，1个网络IO线程同时监听多个TCP套接字,扔到一个队列中缓存起来，进行I/O多路复用
- 1个读写线程用以响应队列中的事件

但除了IO线程、读写线程外，还有后台线程，做一些边角料工作(AOF、对象释放)



Redis 6.0， 使用Master-Worker模型，1个Master线程用来处理数据的写入；

多个worker线程用来进行Socket连接，处理缓存区、等待响应等逻辑，数据读写交回Master线程处理

## 二、Redis为什么高性能



**首先，采用了多路复用io阻塞机制**
**然后，数据结构简单，操作节省时间**
**最后，运行在内存中，自然速度快**



## 三、缓存穿透vs缓存雪崩

### 缓存穿透

一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

如何避免？

1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。

2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。



### 缓存雪崩

当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。

如何避免？

1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期

3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

## 四、Redis事务









| 序号 | 问题                                          | 一句话总结                                                   | 参考文档 |
| ---- | --------------------------------------------- | ------------------------------------------------------------ | -------- |
| 2    | 如何实现分布式锁？                            |                                                              |          |
| 4    | 过期策略                                      | 定期删除+惰性删除+内存淘汰策略<br>redis默认每个隔100ms随机抽查一部分key;<br>因为是抽查，所以部分key过期但一直没被抽到，所以需要惰性删除<br>内存淘汰策略是兜底策略，在redis.conf中配置LRU、random等策略 |          |
| 5    | Redis事务                                     |                                                              |          |
| 6    | 缓存穿透vs 缓存雪崩                           | 缓存穿透：用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，数据库也找不到;<br>缓存雪崩：在同一时刻出现大面积的缓存过期<br><br>解决方案:分布式锁、范围内随机过期时间、缓存预热、布隆过滤器等 |          |
| 7    | Redis为什么高性能？                           | (一)纯内存操作<br>(二)单线程操作，避免了频繁的上下文切换<br>(三)采用了非阻塞I/O多路复用机制 |          |
| 9    | 3种缓存读写策略(旁路缓存、读写穿透、异步写入) |                                                              |          |
| 10   | Node间的命令                                  | Meet, <br>Ping[每个Node每秒去像本地缓存的集群其他节点进行Ping,确保其他人的存活], <br>Pong, <br>Fail, <br>Publish |          |

