## Redis
Remote Dictionary Service 远程字典服务

| 序号 | 问题                                          | 一句话总结                                                   | 参考文档                                                     |
| ---- | --------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 0    | 单进程or单线程？                              | 单线程，因为大部分操作都不需要大量计算，CPU不是瓶颈.相反，网络IO和内存大小才是瓶颈。<br>所以使用NIO:基于Reactor模型，1个网络IO线程同时监听多个TCP套接字,扔到一个队列中缓存起来，进行I/O多路复用；1个读写线程用以响应队列中的事件 |                                                              |
| 1    | 什么版本开始多线程？作用是什么？              | Redis 6.0， 作用是使用Master-Worker模型，1个Master线程用来处理数据的写入；<br>多个worker线程用来进行Socket连接，处理缓存区、等待响应等逻辑，数据读写交回Master线程处理 | [Redis 6.0 多线程IO处理过程详解](https://zhuanlan.zhihu.com/p/144805500) |
| 2    | 如何实现分布式锁？                            | 分布式锁的要求:互斥性、安全性、避免死锁、高可用。<br>基于`mysql行锁`<br>基于`redis`(要通过Lua脚本，因为setnx命令不能原子地设置过期时间。又因为redis集器要考虑更复的场景，所以Redis作者antirez给出了RedLock算法解决,但本质上也不能完全可信)<br>基于`zookeeper` | [Redlock安全吗？](http://antirez.com/news/101)               |
| 4    | 过期策略                                      | 定期删除+惰性删除+内存淘汰策略<br>redis默认每个隔100ms随机抽查一部分key;<br>因为是抽查，所以部分key过期但一直没被抽到，所以需要惰性删除<br>内存淘汰策略是兜底策略，在redis.conf中配置LRU、random等策略 |                                                              |
| 5    | Redis事务                                     |                                                              |                                                              |
| 6    | 缓存穿透vs 缓存雪崩                           | 缓存穿透：用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，数据库也找不到;<br>缓存雪崩：在同一时刻出现大面积的缓存过期<br><br>解决方案:分布式锁、范围内随机过期时间、缓存预热、布隆过滤器等 |                                                              |
| 7    | Redis为什么高性能？                           | (一)纯内存操作<br>(二)单线程操作，避免了频繁的上下文切换<br>(三)采用了非阻塞I/O多路复用机制 |                                                              |
| 8    | 布隆过滤器                                    | 使用多个hash()函数来解决“冲突”；如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中<br> 缺点: 牺牲了准确度和删除便捷性<br> 实现方式：guava包内有，引入依赖即可 <br> **使用场景:防止缓存穿透，先使用布隆过滤器看下是否有缓存，如果布隆过滤器有效，但是Redis为空，可能就是缓存过期了** | [避免缓存击穿的利器之BloomFilter](https://github.com/AobingJava/JavaFamily/blob/master/docs/redis/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8(BloomFilter).md) |
| 9    | 3种缓存读写策略(旁路缓存、读写穿透、异步写入) |                                                              |                                                              |
| 10   | Node间的命令                                  | Meet, <br>Ping[每个Node每秒去像本地缓存的集群其他节点进行Ping,确保其他人的存活], <br>Pong, <br>Fail, <br>Publish |                                                              |

