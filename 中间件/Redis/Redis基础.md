## Redis
| 序号 | 问题                                          | 一句话总结                                                   | 参考文档                                                     |
| ---- | --------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 0    | 单进程or单线程？                              | 单线程，因为大部分操作都不需要大量计算，CPU不是瓶颈.相反，网络IO和内存大小才是瓶颈。<br>所以使用NIO:基于Reactor模型，1个网络IO线程同时监听多个TCP套接字,扔到一个队列中缓存起来，进行I/O多路复用；1个读写线程用以响应队列中的事件 |                                                              |
| 1    | 什么版本开始多线程？作用是什么？              | Redis 6.0， 作用是使用Master-Worker模型，1个Master线程用来处理数据的写入；<br>多个worker线程用来进行Socket连接，处理缓存区、等待响应等逻辑，数据读写交回Master线程处理 | [Redis 6.0 多线程IO处理过程详解](https://zhuanlan.zhihu.com/p/144805500) |
| 2    | 如何实现分布式锁？                            | 分布式锁的要求:互斥性、安全性、避免死锁、高可用。<br>基于`mysql行锁`<br>基于`redis`(要通过Lua脚本，因为setnx命令不能原子地设置过期时间。又因为redis集器要考虑更复的场景，所以Redis作者antirez给出了RedLock算法解决,但本质上也不能完全可信)<br>基于`zookeeper` | [Redlock安全吗？](http://antirez.com/news/101)               |
| 4    | 过期策略                                      | 定期删除+惰性删除+内存淘汰策略<br>redis默认每个隔100ms随机抽查一部分key;<br>因为是抽查，所以部分key过期但一直没被抽到，所以需要惰性删除<br>内存淘汰策略是兜底策略，在redis.conf中配置LRU、random等策略 |                                                              |
| 5    | Redis事务                                     |                                                              |                                                              |
| 6    | 缓存穿透vs 缓存雪崩                           | 缓存穿透：用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，数据库也找不到;<br>缓存雪崩：在同一时刻出现大面积的缓存过期<br><br>解决方案:分布式锁、范围内随机过期时间、缓存预热、布隆过滤器等 |                                                              |
| 7    | Redis为什么高性能？                           | (一)纯内存操作<br>(二)单线程操作，避免了频繁的上下文切换<br>(三)采用了非阻塞I/O多路复用机制 |                                                              |
| 8    | 布隆过滤器                                    | 使用多个hash()函数来解决“冲突”；如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中<br> 缺点: 牺牲了准确度和删除便捷性<br> 实现方式：guava包内有，引入依赖即可 <br> **使用场景:防止缓存穿透，先使用布隆过滤器看下是否有缓存，如果布隆过滤器有效，但是Redis为空，可能就是缓存过期了** | [避免缓存击穿的利器之BloomFilter](https://github.com/AobingJava/JavaFamily/blob/master/docs/redis/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8(BloomFilter).md) |
| 9    | 3种缓存读写策略(旁路缓存、读写穿透、异步写入) |                                                              |                                                              |
| 10   | Node间的命令                                  | Meet, <br>Ping[每个Node每秒去像本地缓存的集群其他节点进行Ping,确保其他人的存活], <br>Pong, <br>Fail, <br>Publish |                                                              |

## Redis持久化

| 序号 | 问题        | 一句话总结                                                   | 参考文档 |
| ---- | ----------- | ------------------------------------------------------------ | -------- |
| 0    | RDB持久化   | Redis如果开启了AOF和RDB，会优先使用AOF，因为性能更好<br>**RDB是快照方式**，周期性地持久化快照, 更耗时、更密集地消耗资源; <br> 但假设持久化周期是5min,最差的情况下会丢失5min的数据 <br> **SAVE命令**会阻塞主进程，直到生成完RDB文件后才响应客户端;一般不使用 <br>**BGSAVE命令**会派生出一个子进程写RDB文件<br> |          |
| 1    | AOF         | **AOF**是增量地，append only地记录每条操作的指令，就很像mysql的binlog.<br>命令先写到**AOF缓冲区**内，默认每秒都要去异步刷新一次日志，进行fsync。<br>**优点**:AOF是1秒1次的，最多丢失1秒的数据，数据一致性更强。<br>**缺点**:同样的数据，AOF文件更大更占空间 |          |
| 2    | AOF重写原理 | 时间久了以后，AOF文件很大，而且很多都是用不到的，比如[set a 123; set a 456; set a 789],其实最终只需要789就行了<br>**原理** : 没有使用分析、合并命令的思路，而是类似RDB一样，分析当前集群的数据状态，生成的命令集合。<br>会新启动一个进程异步进行AOF重写，此时还会多一个**AOF重写缓冲区**，主进程的命令在执行完后，还会同时将命令追加打AOF缓冲区和AOF重写缓冲区 |          |

