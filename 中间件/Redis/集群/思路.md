# **Redis 有哪些架构模式？讲讲各自的特点**

> 1、单机版
>
> 2、主从复制
>
> 3、哨兵
>
> 4、集群模式
>
> 5、代理集群模式





# **单机版**

![img](https://img2018.cnblogs.com/blog/1481291/201809/1481291-20180925142100480-1152515615.png)

特点：简单

问题：

1、内存容量有限 2、处理能力有限 3、无法高可用。

## **主从复制**

**![img](https://img2018.cnblogs.com/blog/1481291/201809/1481291-20180925142118041-1727225479.png)**

Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。

特点：

1、master/slave 角色

2、master/slave 数据相同

3、降低 master 读压力在转交从库

问题：

无法保证高可用

没有解决 master 写的压力

## **哨兵**

**![img](https://img2018.cnblogs.com/blog/1481291/201809/1481291-20180925142143478-1454265814.png)**

Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：

监控（Monitoring）：  Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。

提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。

自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。**当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址**， 使得集群可以使用新主服务器代替失效服务器。

> 哨兵是一个独立的Redis进程，本质和普通的redis-server进程几乎一样 (启动命令都是 ./redis-server sentinel.conf --sentinel)。端口记得不要用6379这样，不要和主节点重复
>
> 但是因为不像真正的Redis-server需要提供读写服务，所以在进程初始化的时候，不必还原RDB或AOF文件
>
> 哨兵模式的其原理是**哨兵进程通过10s一次向主服务器发送命令（gossip protocols），等待Redis服务器响应，从而监控运行的多个Redis实例**



### 特点：

1、保证高可用

2、监控各个节点

3、自动故障迁移

缺点：主从模式，切换需要时间丢数据

没有解决 master 写的压力



用文字描述一下**故障切换（failover）**的过程。

1、假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为**主观下线**。

2、当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票（agreement protocols），投票的结果由一个哨兵发起，进行failover操作。

3、切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**客观下线**。

这样对于客户端而言，一切都是透明的。







## **集群（proxy 型）：**

**![img](https://img2018.cnblogs.com/blog/1481291/201809/1481291-20180925142206124-913246424.png)**

Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。

特点：1、多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins 

2、支持失败节点自动删除

3、后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致

缺点：增加了新的 proxy，需要维护其高可用。

 

failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预



## **集群（直连型）：**

**![img](https://img2018.cnblogs.com/blog/1481291/201809/1481291-20180925142304757-1498788186.png)**

从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。

### 特点：

1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。

2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。

3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。

4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本

5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。

### 缺点：

1、资源隔离性较差，容易出现相互影响的情况。

2、数据通过异步复制,不保证数据的强一致性



### 关键点

(0)主节点负责写，从节点只能读，且会同步来自主节点的命令

(1)使用cluster meet命令将节点连接

(2)通过Gossip协议来交换各自关于不同节点的状态信息

(3)数据分片,16384(1024\*2\*8)个槽，数据结构是bitmap,每一位表示一个槽。每个主-从节点负责一部分槽, 使用CRC16(key)&16384来决定key的归属



## redis集群模式常见问题

| 序号 | 问题                         | 一句话总结                                                   |
| ---- | ---------------------------- | ------------------------------------------------------------ |
| 1    | 1个节点down掉，redis怎么处理 | 一、各个节点定期互相Ping(自己的Ping命令，不是TCP的Ping), 如果节点7000Ping不通，就将本地缓存的节点7000的ClusterNode对象标记其为PFAIL(疑似下线状态)<br>二、各个节点互相还会同步自己的缓存；同时将其他节点节点对7000的状态存在ClusterNode的一个链表里<br>三、如果一个集群中，过半的主节点都认为7000疑似下线了，就会有一个节点标记7000为FAIL下线，并发广播通知；其他收到广播的节点也会将其标记为FAIL下线 |
| 2    | 故障转移                     | 一、当7000的一个从节点发现7000处于FAIL状态了，就会通知其他主节点，其他主节点就会在所有7000的从节点内**选一个作为主节点(即选举)**，<br>二、然后将主节点的槽全部指派给自己<br>三、向集群发一条广播的PONG消息，通知其他节点自己是主节点啦 |
| 3    | 选举主节点                   | 当过半的主节点都vote给了一个从节点，这个从节点就成为那部分槽的主节点<br>如果没有过半的，就重新选举，直到过半<br>选举算法是基于Raft的领头选举的 |

