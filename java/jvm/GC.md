## 面试题

| 序号 | 问题                             | 一句话总结                     |
| ---- | -------------------------------- | ------------------------------ |
| 0    | 如何判断对象已经死亡，即需要GC？ | 可达性分析vs引用计数法         |
| 1    | GC算法有哪些                     | 标记-清除<br>标记-整理<br>复制 |
| 2    | 垃圾回收器都有哪些，可以怎么配合 |                                |
| 3    | 参数都有哪些，可以如何调优       |                                |
| 4    | 有哪几种GC，区别是什么           |                                |
| 5    | GC失败的情况有哪些，怎么处理     |                                |

### 如何判断对象已经死亡，需要GC？

1. 可达性分析

   当一个对象不可达时，就认为该对象用不到了，可以GC了。

   所谓的可达性就是通过一系列称为“GC Roots”的对象为起点从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是GC Roots到这个对象不可达）时，则说明此对象是不可用的。

   

   那么那些对象可以作为GC Roots呢？以Java为例，有以下几种：

   - 栈（栈帧中的本地变量表）中引用的对象。

   - 方法区中的静态成员。

   - 方法区中的常量引用的对象（全局变量）。

   - 本地方法栈中JNI（一般说的Native方法）引用的对象。

   注：第一和第四种都是指的方法的本地变量表，第二种表达的意思比较清晰，第三种主要指的是声明为final的常量值。

   

2. 引用计数法

   所谓的引用计数法就是给每个对象一个引用计数器，每当有一个地方引用它时，计数器就会加1；当引用失效时，计数器的值就会减1；

   任何时刻计数器的值为0的对象就是不可能再被使用的。

   >  这个引用计数法时没有被Java所使用的，但是python有使用到它。而且最原始的引用计数法没有用到GC Roots。

### GC算法

1. 常见的GC算法有哪些，各自的特点是什么
   一般是3种：【标记-清除】and 【复制】and 【标记-整理】  

- 标记- 清除算法

  - 该算法分为“标记”和“清除”阶段：⾸先标记出所有不需要回收的对象，在标记完成后统⼀回收掉所有没有被标记的对象。
  - 它是最基础的收集算法，后续的算法都是对其不⾜进⾏改进得到。
  - 这种垃圾收集算法会带来两个明显的问题：
    - 1. 效率问题
    - 2. 空间问题(标记清除后会产⽣⼤量不连续的碎⽚)  

  ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f73566a5f32f48b58a3d022420997f9c~tplv-k3u1fbpfcp-watermark.image)

- 复制算法

  - 为了解决效率问题，“复制”收集算法出现了。
  - 它可以将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收。
  - 优点： 高效、没有内存碎片 (正好是标记-清除 算法的缺点)
  - 缺点： 浪费空间，至少有一半的空间被浪费

  

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40ccd6a990a243178ef3cc36eca22aed~tplv-k3u1fbpfcp-watermark.image)
      

- 标记- 整理算法
  - 标记过程仍然与“标记-清除”算法⼀样，但后续步骤不是直接对可回收对象回收，⽽是让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存。
  - 一般是根据⽼年代的特点提出的⼀种标记算法，

- 分代收集。其实不是一种算法，而只是一种思路：  
  - 只是根据对象存活周期的不同将内存分为⼏块。⼀般将 java 堆分为新⽣代和⽼年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。  
  - 目的： 分类，然后提高GC效率  

  - 使用思路：
    - ⽐如在新⽣代中，每次收集都会有⼤量对象死去，所以可以选择复制算法，高效  
    - ⽽⽼年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集