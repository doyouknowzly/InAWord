# Garbage First (G1)



## 1、G1以前收集器的特点是？

> （1）年轻代和老年代是各自独立且连续的内存块
> （2）年轻代收集使用单eden+S0 +S进行复制算法
> （3）老年代收集必须扫描整个老年代区域
> （4）都是以尽可能少而快速地执行GC为设计原则
>
> 

## 2、G1是什么？

G1（Garbage-First）收集器，是一款面向服务端的应用的收集器



G1设计的目标是让stop the world的时间是可预测和可配置的。C1垃圾回收器是软实时，低延迟的垃圾回收器，你可以设置你需要的性能目标。它解决了CMS中空间碎片的问题.

CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是它还是存在着内存碎片问题。于是，为了去除内存碎片问题，同时保留CMS垃圾收集器低暂停时间的优化，java7发布了一个新垃圾收集器--**G1垃圾收集器**。G1在JDK9取代了默认的Parallel GC 关注吞吐量的组合成为默认的垃圾回收器，而CMS在Jdk9被移除了。



G1不要求将年轻代和老年代用连续的空间来实现，堆会被划分成一系列的小region，通常默认是2048块，任何一个region可能是eden区，survivor区，或者是老年代区，但是不能一个region有多个区，只能是其中一个。每块Region取值范围为1M到32M，并且只能是2的n次幂，可以通过虚拟机参数：

![G1垃圾回收器](https://pic3.zhimg.com/v2-035090591f6287adc89985a073b235d0_1440w.jpg?source=172ae18b)



-XX:G1HeapRegionSize来设置大小，所有的eden和survivor区的总和就是年轻代的大小，所有老年代的总和就是老年代的大小。

这种化分区域的方式，使得垃圾回收的时候，不需要对很大的一块区域进行垃圾回收（比如serial系列垃圾收集器，要么整块年轻代，要么整个堆进行回收），而是逐步的进行回收，仅仅回收一部分region，即回收region的整数倍区域。

**年轻代回收的时候，会stop the world**，当存在跨代引用的时候会包含部分的老年代被回收，这一次回收的部分称为回收集。如下图，被框了（有黑色框）的部分就是这一次垃圾回收会处理的region。



![img](https://pic4.zhimg.com/80/v2-689fcf1ba20630746b9f2898dc4fd19f_720w.jpg)

G1可以评估每一个region存活对象的数量和回收该区域所需要的时间经验值，来维护一个优先级列表，每次根据用户设置的停顿时间（可以使用参数：-XX:MaxGCPauseMillis设置）,**优先回收包含比较多垃圾对象的regions**，这也是该垃圾回收器名称Garbage first的由来。



# 3、G1的运行流程

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200730161610159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMjI4MTI4NDk=,size_16,color_FFFFFF,t_70)

G1的运行过程与CMS大体一致，分为以下四个步骤：

### 初始标记(Initial Marking)：[短暂地stw]

仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。

### 并发标记( Concurrent Marking)：

从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，并发时有引用变动的对象会产生漏标问题，G1中会使用SATB(snapshot-at-the-beginning)算法来解决，后面会详细介绍。

### 最终标记(Final Marking)：[短暂地stw]

对用户线程做一个短暂的暂停，用于处理并发标记阶段仍遗留下来的最后那少量的SATB记录(漏标对象)。

### 筛选回收(Live Data Counting and Evacuation)：[stw]

负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。





>  TAMS是什么？

要达到GC与用户线程并发运行，必须要解决回收过程中新对象的分配.

所以G1为每一个Region区域设计了两个名为TAMS（Top at Mark Start）的指针，从Region区域划出一部分空间用于记录并发回收过程中的新对象。这样的对象认为它们是存活的，不纳入垃圾回收范围。
