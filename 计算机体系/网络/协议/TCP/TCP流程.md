# TCP流程

参考文档

(https://juejin.cn/post/6844903958624878606)

(https://zhuanlan.zhihu.com/p/40013724)

(https://zhuanlan.zhihu.com/p/152120241)

| 序号 | 问题                                       | 一句话解释 |
| ---- | ------------------------------------------ | ---------- |
| 1    | 为什么要3次握手，2次不行么                 |            |
| 2    | 为什么要4次挥手                            |            |
| 3    | TCP双方可能的状态                          |            |
| 4    | 如果有大量的time_wait， 什么原因，怎么处理 |            |



## 1. 3次握手

**为什么要握手**  
握手的双方，知道对方ack的起始值，那么两方就知道对面发送了多少字节的报文，自己接收到了多少(每个报文中有偏移量)； 如果出现了丢包or超时，就可以做对应的处理(重发、等待等)，从而保证了稳定性and连续性

**握手的流程**

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f72d9bf3ea047a5b93e326c0b55a184~tplv-k3u1fbpfcp-watermark.image)

- 第1次握手：客户端将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。
- 第2次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。
- 第3次握手：客户端收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给服务器端，服务器端检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

> 一句话概括，TCP连接握手，握的是啥？  
> **通信双方数据原点的序列号！，即ack**



###  1.1为什么要3次， 2次不行么  

如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。  



### 1.2. 三次握手过程中可以携带数据吗？

其实第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手不可以携带数据**

为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

也就是说，**第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。**






## 2. 4次挥手

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ae42b432fe848ff9ecd85b2e91a9341~tplv-k3u1fbpfcp-watermark.image)

### 2.1为什么挥手要4次

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。



### 2.2  2MSL等待状态

> **MSL**是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。

这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。




### 2.3 四次挥手释放连接时，等待2MSL的意义?

为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。



#### 两个理由：

1. 保证客户端发送的最后一个ACK报文段能够到达服务端。 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。
2. 防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。



### 2.3 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？

理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。

所以**TIME_WAIT状态就是用来重发可能丢失的ACK报文**。



## 3. TCP双方可能的状态

```java
Listen监听状态;
SYN_SENT发送状态;
SYN_RECV状态;
Established状态等待发送报文;
fin_wait_1状态;
close_wait状态;
fin_wait_2状态;
last_ack状态;
time_wait状态;
closed状态
```



#### 3.1 常见的TCP状态

常用的三个状态是：**ESTABLISHED** 表示正在通信，**TIME_WAIT** 表示主动关闭，**CLOSE_WAIT** 表示被动关闭。

查看网络状态，如果出现以下两种问题，服务器一般都出了异常。

- 服务器保持了大量TIME_WAIT状态
- 服务器保持了大量CLOSE_WAIT状态

因为linux分配给一个用户的文件句柄是有限的，而TIME_WAIT和CLOSE_WAIT两种状态如果一直被保持，那么意味着对应数目的通道就一直被占着，一旦达到句柄数上限，新的请求就无法被处理了，接着就是大量Too Many Open Files异常，最终导致tomcat等容器崩溃。



#### 3.2 TCP状态流转

![img](https://user-gold-cdn.xitu.io/2019/8/4/16c5bdb3b51fb782?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



## 4.如果有大量的time_wait， 什么原因，怎么处理

### 4.1 time_wait的作用

TCP要保证在所有可能的情况下使得所有的数据都能够被正确送达。当你关闭一个socket时，主动关闭一端的socket将进入TIME_WAIT状态，而被动关闭一方则转入CLOSED状态，这的确能够保证所有的数据都被传输。当一个socket关闭的时候，是通过两端四次握手完成的，当一端调用close()时，就说明本端没有数据要发送了。这好似看来在握手完成以后，socket就都可以处于初始的CLOSED状态了，其实不然。原因是这样安排状态有两个问题，

- 首先，我们没有任何机制保证最后的一个ACK能够正常传输
- 第二，网络上仍然有可能有残余的数据包(wandering duplicates)，我们也必须能够正常处理。

              TIMEWAIT就是为了解决这两个问题而生的。


### 4.2 大量time_wait的可能原因

在高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接

这个场景下，会出现大量socket处于TIME_WAIT状态。

如果客户端的并发量持续很高，此时部分客户端就会显示连接不上

### 4.3 解决方案