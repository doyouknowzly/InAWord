# HTTPS

## 引言

《图解HTTP》这本书中曾提过, HTTPS是**身披SSL外壳**的HTTP. 

主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。

其中，HTTP协议使用80端口，HTTPS使用443端口

> TLS是传输层加密协议，前身是SSL协议，由网景公司(Netscape)1995年发布，有些语境下两者可认为是一样的。
>
> 其中，SSL1.0-3.0因为存在的安全漏洞，基本上都弃用了，TLS1.0同样； 比较常用的是TLS1.1和1.2

## HTTP面临的问题

HTTPS要解决下面这些HTTP遇到的安全性问题 : 

1. 通信使用明文, 可能会被窃听

2. 不验证通信方的身份可能遭遇伪装

3. 无法证明报文的完整型，可能中途已遭篡改(中间人攻击)

#### 1.被窃听

​	解决思路: 使用对称加密算法，明文变密文

> 遇到的问题: 对称加密的密钥怎么决定? 
>
> 使用约定好的密钥？怎么可能，那每一个连接的客户端都能知道密钥
>
> 密钥传输在报文里？你这个密钥就是用来加密报文的，密钥总不能明文写到报文里吧
>
> 所以密钥要用**非对称算法加密**，这样只需要服务端维护一个公钥即可

#### 2.被伪装

​	解决思路: 数字签名(数字摘要后， 私钥加密)

> 此处要注意，公钥的信任问题，因为公钥和公钥加密的text都是发送方传来的，可能这个时候公钥已经被篡改了，那text也很可能是用假的公钥加密的
>
> 所以引入了CA， 通信双方都存有被大家信任的、大公司的公钥，CA用其私钥加密我们自己的公钥，作为签名 追加到我们的text后面
>
> 消费方使用大公司的公钥即可解密，拿到安全的、真正的发送方的公钥                                            

#### 3.被篡改

​	解决思路: 数字摘要



## 流程

1. 服务端向大公司(CA)申请证书

2. **CA用自己的私钥**，给服务端的公钥加密，作为证书(内容有公钥，网站地址，证书日期等)，服务端自己存档

3. 客户端发起请求，到服务器的443端口

4. 服务端将response使用自己的公钥加密 (没什么内容，现在还处于建立ssl信任，还不传输复杂的http报文)

   ，再将存档的证书附在密文后面，发送给客户端，同时还有证书的数字摘要(也叫做证书的指纹)

   > 如果需要客户端也提供证书的话，还会发出客户端证书请求(Client Certificate Request)，
   >
   > 只有少数金融机构才需要客户端也提供客户端证书。

5. 客户端校验指纹，得出证书是否可信(也可以人为接受未知来源的证书)

   > 大公司(CA)的证书在安装操作系统时就预装了 

6. 先找到是哪个CA的证书，找到其公钥，用公钥解密指纹，解密后的签名就是证书的摘要A；

   证书中本来又带有服务端的公钥，使用证书中声明的签名算法签名,结果是B，如果A==B，就OK

7. 验证通过后，客户端就拿到了**服务端的公钥**，并且是可以信任的，没被替换的

8. 客户端生成对称加密的密钥，用服务端的公钥加密，

9. 服务端收到后，使用自己的私钥解密，拿到对称加密的密钥

   > 目的1. 不用保存各个客户端的对称密钥，传输中带过来
   >
   > 目的2. 对称加密性能高，非对称太慢了，只能加密小数据量的签名等内容

10. 之后的http传输内容都使用这个对称加密的密钥来加密



## 感悟

目前的技术还没法完全避免中间人攻击，HTTPS的思路其实跟几千年前的"见证人"一样， 做生意前找当地有声望的士绅、大商人给做个见证，证明你是你，他是他。

HTTPS的思路总结如下:

1、想用对称加密，因为非对称加密太慢了

2、对称加密密钥太多了不好维护怎么办？ 让客户端自己生成传过来吧

3、传过来的时候，密钥不能是明文吧？ 加个密

4、密钥加密怎么办？ 使用非对称加密(加密小数据的速度还是可以的)

5、怎么保证过程没有被篡改？ 大公司使用自己私钥给服务端做签名